-- MySQL Script generated by MySQL Workbench
-- 03/09/18 11:21:20
-- Model: GrandChef Model    Version: 1.9.3.5
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema GrandChef
-- -----------------------------------------------------
-- Armazena todas as informações do sistema GrandChef, exceto configurações de janelas, conexão e lembrete de sessão
DROP SCHEMA IF EXISTS `GrandChef` ;

-- -----------------------------------------------------
-- Schema GrandChef
--
-- Armazena todas as informações do sistema GrandChef, exceto configurações de janelas, conexão e lembrete de sessão
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `GrandChef` DEFAULT CHARACTER SET utf8 ;
USE `GrandChef` ;

-- -----------------------------------------------------
-- Table `Mesas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Mesas` ;

CREATE TABLE IF NOT EXISTS `Mesas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Número da mesa[N:Número][G:o]',
  `Nome` VARCHAR(50) NOT NULL COMMENT 'Nome da mesa[N:Nome][G:o][S]',
  `Ativa` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se a mesa está disponível para lançamento de pedidos[N:Ativa][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC))
ENGINE = InnoDB
COMMENT = 'Mesas para lançamento de pedidos[N:Mesa|Mesas][G:a][L:Cadas' /* comment truncated */ /*troMesas][K:MZ\Environment|MZ\Environment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Sessoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Sessoes` ;

CREATE TABLE IF NOT EXISTS `Sessoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código da sessão[G:o]',
  `DataInicio` DATETIME NOT NULL COMMENT 'Data de início da sessão[N:Data de início][G:a]',
  `DataTermino` DATETIME NULL DEFAULT NULL COMMENT 'Data de fechamento da sessão[N:Data de termíno][G:a]',
  `Aberta` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se a sessão está aberta[N:Aberta][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `IDX_Sessoes_Aberta` (`Aberta` ASC))
ENGINE = InnoDB
COMMENT = 'Sessão de trabalho do dia, permite que vários caixas sejam' /* comment truncated */ /* abertos utilizando uma mesma sessão[N:Sessão|Sessões][G:a][L:AbrirCaixa][K:MZ\Session|MZ\Session\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Caixas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Caixas` ;

CREATE TABLE IF NOT EXISTS `Caixas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do caixa[G:o]',
  `Descricao` VARCHAR(50) NOT NULL COMMENT 'Descrição do caixa[N:Descrição][G:a][S]',
  `Serie` INT NOT NULL DEFAULT 1 COMMENT 'Série do caixa[N:Série][G:a]',
  `NumeroInicial` INT NOT NULL DEFAULT 1 COMMENT 'Número inicial na geração da nota, será usado quando maior que o último número utilizado[N:Número inicial][G:o]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o caixa está ativo[N:Ativo][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC))
ENGINE = InnoDB
COMMENT = 'Caixas de movimentação financeira[N:Caixa|Caixas][G:o][L:C' /* comment truncated */ /*adastroCaixas][K:MZ\Session|MZ\Session\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Bancos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Bancos` ;

CREATE TABLE IF NOT EXISTS `Bancos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do banco[G:o]',
  `Numero` VARCHAR(40) NOT NULL COMMENT 'Número do banco[N:Número][G:o]',
  `RazaoSocial` VARCHAR(200) NOT NULL COMMENT 'Razão social do banco[N:Razão social][G:a][S]',
  `AgenciaMascara` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Mascara para formatação do número da agência[N:Máscara da agência][G:a]',
  `ContaMascara` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Máscara para formatação do número da conta[N:Máscara da conta][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `RazaoSocial_UNIQUE` (`RazaoSocial` ASC),
  UNIQUE INDEX `Numero_UNIQUE` (`Numero` ASC))
ENGINE = InnoDB
COMMENT = 'Bancos disponíveis no país[N:Banco|Bancos][G:o][L:Cadastro' /* comment truncated */ /*Bancos][K:MZ\Wallet|MZ\Wallet\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Carteiras`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Carteiras` ;

CREATE TABLE IF NOT EXISTS `Carteiras` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código local da carteira[G:o]',
  `Tipo` ENUM('Bancaria', 'Financeira') NOT NULL COMMENT 'Tipo de carteira, \'Bancaria\' para conta bancária e \'Financeira\' para carteira financeira da empresa ou de sites de pagamentos[N:Tipo][G:o][S:S][E:Bancária|Financeira]',
  `BancoID` INT NULL DEFAULT NULL COMMENT 'Código local do banco quando a carteira for bancária[N:Banco][G:o][S:S]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descrição da carteira, nome dado a carteira cadastrada[N:Descrição][G:a][S]',
  `Conta` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Número da conta bancária ou usuário da conta de acesso da carteira[N:Conta][G:a]',
  `Agencia` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Número da agência da conta bancária ou site da carteira financeira[N:Agência][G:a]',
  `Ativa` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se a carteira ou conta bancária está ativa[N:Ativa][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Carteiras_Bancos_BancoID_idx` (`BancoID` ASC),
  CONSTRAINT `FK_Carteiras_Bancos_BancoID`
    FOREIGN KEY (`BancoID`)
    REFERENCES `Bancos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa uma conta bancária ou uma carteira financeira[N:Car' /* comment truncated */ /*teira|Carteiras][G:a][L:CadastroCarteiras][K:MZ\Wallet|MZ\Wallet\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Formas_Pagto`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Formas_Pagto` ;

CREATE TABLE IF NOT EXISTS `Formas_Pagto` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da forma de pagamento[G:o]',
  `Tipo` ENUM('Dinheiro', 'Cartao', 'Cheque', 'Conta', 'Credito', 'Transferencia') NOT NULL COMMENT 'Tipo de pagamento[N:Tipo][G:o][E:Dinheiro|Cartão|Cheque|Conta|Crédito|Transferência][S:S]',
  `CarteiraID` INT NOT NULL COMMENT 'Carteira que será usada para entrada de valores no caixa[N:Carteira de entrada][G:a]',
  `CarteiraPagtoID` INT NOT NULL COMMENT 'Carteira de saída de valores do caixa[N:Carteira de saída][G:a]',
  `Descricao` VARCHAR(50) NOT NULL COMMENT 'Descrição da forma de pagamento[N:Descrição][G:a][S]',
  `Parcelado` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se a forma de pagamento permite parcelamento[N:Parcelado][G:o]',
  `MinParcelas` INT NULL DEFAULT NULL COMMENT 'Quantidade mínima de parcelas[N:Minimo de parcelas][G:a]',
  `MaxParcelas` INT NULL DEFAULT NULL COMMENT 'Quantidade máxima de parcelas[N:Máximo de parcelas][G:o]',
  `ParcelasSemJuros` INT NULL DEFAULT NULL COMMENT 'Quantidade de parcelas em que não será cobrado juros[N:Parcelas sem juros][G:a]',
  `Juros` DOUBLE NULL DEFAULT NULL COMMENT 'Juros cobrado ao cliente no parcelamento[N:Juros][G:o]',
  `Ativa` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se a forma de pagamento está ativa[N:Ativa][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC),
  INDEX `FK_Formas_Pagto_Carteiras_CarteiraID_idx` (`CarteiraID` ASC),
  INDEX `FK_Formas_Pagto_Carteiras_CarteiraPagtoID_idx` (`CarteiraPagtoID` ASC),
  CONSTRAINT `FK_Formas_Pagto_Carteiras_CarteiraID`
    FOREIGN KEY (`CarteiraID`)
    REFERENCES `Carteiras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Formas_Pagto_Carteiras_CarteiraPagtoID`
    FOREIGN KEY (`CarteiraPagtoID`)
    REFERENCES `Carteiras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Formas de pagamento disponíveis para pedido e contas[N:Form' /* comment truncated */ /*a de pagamento|Formas de pagamento][G:a][L:CadastroFormasPagto][K:MZ\Payment|MZ\Payment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Cartoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Cartoes` ;

CREATE TABLE IF NOT EXISTS `Cartoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do cartão[G:o]',
  `CarteiraID` INT NULL DEFAULT NULL COMMENT 'Carteira de entrada de valores no caixa[N:Carteira de entrada][G:a]',
  `CarteiraPagtoID` INT NULL DEFAULT NULL COMMENT 'Carteira de saída de pagamentos no caixa[N:Carteira de saída][G:a]',
  `Descricao` VARCHAR(50) NOT NULL COMMENT 'Descrição do cartão[N:Descrição][G:a][S]',
  `ImageIndex` INT NULL DEFAULT NULL COMMENT 'Índice da imagem do cartão[N:Índice da imagem][G:a]',
  `Mensalidade` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Valor da mensalidade cobrada pela operadora do cartão[N:Mensalidade][G:a]',
  `Transacao` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Valor cobrado pela operadora para cada transação com o cartão[N:Transação][G:a]',
  `Taxa` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Taxa em porcentagem cobrado sobre o total do pagamento, valores de 0 a 100[N:Taxa][G:a]',
  `DiasRepasse` INT UNSIGNED NOT NULL DEFAULT 30 COMMENT 'Quantidade de dias para repasse do valor[N:Dias para repasse][G:o]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o cartão está ativo[N:Ativo][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC),
  INDEX `FK_Cartoes_Carteiras_CarteiraID_idx` (`CarteiraID` ASC),
  INDEX `FK_Cartoes_Carteiras_CarteiraPagtoID_idx` (`CarteiraPagtoID` ASC),
  CONSTRAINT `FK_Cartoes_Carteiras_CarteiraID`
    FOREIGN KEY (`CarteiraID`)
    REFERENCES `Carteiras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Cartoes_Carteiras_CarteiraPagtoID`
    FOREIGN KEY (`CarteiraPagtoID`)
    REFERENCES `Carteiras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Cartões utilizados na forma de pagamento em cartão[N:Ca' /* comment truncated */ /*rtão|Cartões][G:o][L:CadastroCartoes][K:MZ\Payment|MZ\Payment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Funcoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Funcoes` ;

CREATE TABLE IF NOT EXISTS `Funcoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da função[G:o]',
  `Descricao` VARCHAR(45) NOT NULL COMMENT 'Descreve o nome da função[N:Descrição][G:a][S]',
  `SalarioBase` DECIMAL(19,4) NOT NULL COMMENT 'Salário base ou mínimo que será acrescentado comissões[N:Salário base][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC))
ENGINE = InnoDB
COMMENT = 'Função ou cargo de um funcionário[N:Função|Funções][G' /* comment truncated */ /*:a][L:AlterarConfiguracoes][K:MZ\Employee|MZ\Employee\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Clientes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Clientes` ;

CREATE TABLE IF NOT EXISTS `Clientes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do cliente[G:o]',
  `Tipo` ENUM('Fisica', 'Juridica') NOT NULL DEFAULT 'Fisica' COMMENT 'Informa o tipo de pessoa, que pode ser física ou jurídica[N:Tipo][G:o][E:Física|Jurídica][S:S]',
  `AcionistaID` INT NULL DEFAULT NULL COMMENT 'Informa quem é o acionista principal da empresa, obrigatoriamente o cliente deve ser uma pessoa jurídica e o acionista uma pessoa física[N:Acionista][G:o][S:S]',
  `Login` VARCHAR(50) NULL COMMENT 'Nome de usuário utilizado para entrar no sistema, aplicativo ou site[N:Login][G:o]',
  `Senha` VARCHAR(40) NULL DEFAULT NULL COMMENT 'Senha embaralhada do cliente ou funcionário[N:Senha][G:a][P]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Primeiro nome da pessoa física ou nome fantasia da empresa[N:Nome][G:o][S]',
  `Sobrenome` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Restante do nome da pessoa física ou Razão social da empresa[N:Sobrenome][G:o]',
  `Genero` ENUM('Masculino', 'Feminino') NULL DEFAULT 'Masculino' COMMENT 'Informa o gênero do cliente do tipo pessoa física[N:Gênero][G:o][S:S][R]',
  `CPF` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Cadastro de Pessoa Física(CPF) ou Cadastro Nacional de Pessoa Jurídica(CNPJ)[M:999.999.999-99][N:CPF][G:o]',
  `RG` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Registro Geral(RG) ou Inscrição Estadual (IE)[N:Registro Geral][G:o]',
  `IM` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Inscrição municipal da empresa[N:Inscrição municipal][G:a]',
  `Email` VARCHAR(100) NULL DEFAULT NULL COMMENT 'E-mail do cliente ou da empresa[N:E-mail][G:o]',
  `DataAniversario` DATE NULL DEFAULT NULL COMMENT 'Data de aniversário sem o ano ou data de fundação[N:Data de aniversário][G:a] ',
  `Fone1` VARCHAR(12) NULL DEFAULT NULL COMMENT 'Telefone principal do cliente, deve ser único[M:(99) 9999-9999?9][N:Telefone][G:o]',
  `Fone2` VARCHAR(12) NULL DEFAULT NULL COMMENT 'Telefone opcional[M:(99) 9999-9999?9][N:Celular][G:o]',
  `Slogan` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Slogan ou detalhes do cliente[N:Observação][G:a]',
  `Secreto` VARCHAR(40) NULL DEFAULT NULL COMMENT 'Código secreto para recuperar a conta do cliente[N:Código de recuperação][G:o][D]',
  `LimiteCompra` DECIMAL(19,4) NULL DEFAULT NULL COMMENT 'Limite de compra utilizando a forma de pagamento Conta[N:Limite de compra][G:o]',
  `FacebookURL` VARCHAR(200) NULL DEFAULT NULL COMMENT 'URL para acessar a página do Facebook do cliente[N:Facebook][G:o]',
  `TwitterURL` VARCHAR(200) NULL DEFAULT NULL COMMENT 'URL para acessar a página do Twitter do cliente[N:Twitter][G:o]',
  `LinkedInURL` VARCHAR(200) NULL DEFAULT NULL COMMENT 'URL para acessar a página do LinkedIn do cliente[N:LinkedIn][G:o]',
  `Imagem` MEDIUMBLOB NULL DEFAULT NULL COMMENT 'Foto do cliente ou logo da empresa[I:256x256|cliente|cliente.png][N:Foto][G:a]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização das informações do cliente[N:Data de atualização][G:a][D]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro do cliente[N:Data de cadastro][G:a][D]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Fone1_UNIQUE` (`Fone1` ASC),
  UNIQUE INDEX `Email_UNIQUE` (`Email` ASC),
  INDEX `Nome_INDEX` (`Nome` ASC),
  UNIQUE INDEX `CPF_UNIQUE` (`CPF` ASC),
  UNIQUE INDEX `Login_UNIQUE` (`Login` ASC),
  INDEX `Fone2_INDEX` (`Fone2` ASC),
  UNIQUE INDEX `Secreto_UNIQUE` (`Secreto` ASC),
  INDEX `FK_Clientes_Clientes_AcionistaID_idx` (`AcionistaID` ASC),
  CONSTRAINT `FK_Clientes_Clientes_AcionistaID`
    FOREIGN KEY (`AcionistaID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informações de cliente físico ou jurídico. Clientes, emp' /* comment truncated */ /*resas, funcionários, fornecedores e parceiros são cadastrados aqui[N:Cliente|Clientes][G:o][L:CadastroClientes][K:MZ\Account|MZ\Account\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Funcionarios`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Funcionarios` ;

CREATE TABLE IF NOT EXISTS `Funcionarios` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código do funcionário[N:Código][G:o]',
  `FuncaoID` INT NOT NULL COMMENT 'Função do funcionário na empresa[N:Função][G:a][S:S]',
  `ClienteID` INT NOT NULL COMMENT 'Cliente que representa esse funcionário, único no cadastro de funcionários[N:Cliente][G:o][S]',
  `CodigoBarras` VARCHAR(13) NULL DEFAULT NULL COMMENT 'Código de barras utilizado pelo funcionário para autorizar uma operação no sistema[N:Código de barras][G:o]',
  `Porcentagem` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Porcentagem cobrada pelo funcionário ao cliente, Ex.: Comissão de 10% [N:Comissão][G:a]',
  `LinguagemID` INT NOT NULL DEFAULT 0 COMMENT 'Código da linguagem utilizada pelo funcionário para visualizar o programa e o site[N:Linguagem][G:a]',
  `Pontuacao` INT NOT NULL DEFAULT 0 COMMENT 'Define a distribuição da porcentagem pela parcela de pontos[N:Pontuação][G:a]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o funcionário está ativo na empresa[N:Ativo][G:o]',
  `DataSaida` DATETIME NULL DEFAULT NULL COMMENT 'Data de saída do funcionário, informado apenas quando ativo for não[N:Data de saída][G:a][D]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data em que o funcionário foi cadastrado no sistema[N:Data de cadastro][G:a][D]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Funcionarios_Funcoes_FuncaoID_idx` (`FuncaoID` ASC),
  UNIQUE INDEX `UK_ClienteID` (`ClienteID` ASC),
  UNIQUE INDEX `CodigoBarras_UNIQUE` (`CodigoBarras` ASC),
  CONSTRAINT `FK_Funcionarios_Funcoes_FuncaoID`
    FOREIGN KEY (`FuncaoID`)
    REFERENCES `Funcoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Funcionarios_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Funcionário que trabalha na empresa e possui uma determinad' /* comment truncated */ /*a função[N:Funcionário|Funcionários][G:o][L:CadastroFuncionarios][K:MZ\Employee|MZ\Employee\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Moedas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Moedas` ;

CREATE TABLE IF NOT EXISTS `Moedas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da moeda[G:o]',
  `Nome` VARCHAR(45) NOT NULL COMMENT 'Nome da moeda[N:Nome][G:o][S]',
  `Simbolo` VARCHAR(10) NOT NULL COMMENT 'Símbolo da moeda, Ex.: R$, $[N:Símbolo][G:o]',
  `Codigo` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Código internacional da moeda, Ex.: USD, BRL[N:Código][G:o]',
  `Divisao` INT NOT NULL COMMENT 'Informa o número fracionário para determinar a quantidade de casas decimais, Ex: 100 para 0,00. 10 para 0,0[N:Divisão][G:a]',
  `Fracao` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Informa o nome da fração, Ex.: Centavo[N:Nome da fração][G:o]',
  `Formato` VARCHAR(45) NOT NULL COMMENT 'Formado de exibição do valor, Ex: $ %s, para $ 3,00[N:Formato][G:o]',
  PRIMARY KEY (`ID`))
ENGINE = InnoDB
COMMENT = 'Moedas financeiras de um país[N:Moeda|Moedas][G:a][L:Cadast' /* comment truncated */ /*roMoedas][K:MZ\Wallet|MZ\Wallet\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Paises`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Paises` ;

CREATE TABLE IF NOT EXISTS `Paises` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do país[G:o]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome do país[N:Nome][G:o][S]',
  `Sigla` VARCHAR(10) NOT NULL COMMENT 'Abreviação do nome do país[N:Sigla][G:a]',
  `MoedaID` INT NOT NULL COMMENT 'Informa a moeda principal do país[N:Moeda][G:a]',
  `BandeiraIndex` INT NOT NULL COMMENT 'Index da imagem da bandeira do país[N:Bandeira][G:a]',
  `LinguagemID` INT NOT NULL DEFAULT 0 COMMENT 'Linguagem nativa do país[N:Linguagem ID][G:a]',
  `Entradas` TEXT NULL DEFAULT NULL COMMENT 'Frases, nomes de campos e máscaras específicas do país[N:Entrada][G:a]',
  `Unitario` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o país tem apenas um estado federativo[N:Unitário][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC),
  INDEX `FK_Paises_Moedas_MoedaID_idx` (`MoedaID` ASC),
  UNIQUE INDEX `Sigla_UNIQUE` (`Sigla` ASC),
  CONSTRAINT `FK_Paises_Moedas_MoedaID`
    FOREIGN KEY (`MoedaID`)
    REFERENCES `Moedas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informações de um páis com sua moeda e língua nativa[N:P' /* comment truncated */ /*aís|Paises][G:o][L:CadastroPaises][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Estados`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Estados` ;

CREATE TABLE IF NOT EXISTS `Estados` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do estado[G:o]',
  `PaisID` INT NOT NULL COMMENT 'País a qual esse estado pertence[N:País][G:o][S:S]',
  `Nome` VARCHAR(64) NOT NULL COMMENT 'Nome do estado[N:Nome][G:o][S]',
  `UF` VARCHAR(48) NOT NULL COMMENT 'Sigla do estado[N:UF]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `PaisID_Nome_UNIQUE` (`PaisID` ASC, `Nome` ASC),
  UNIQUE INDEX `PaisID_UF_UNIQUE` (`PaisID` ASC, `UF` ASC),
  CONSTRAINT `FK_Estados_Paises_PaisID`
    FOREIGN KEY (`PaisID`)
    REFERENCES `Paises` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Estado federativo de um país[N:Estado|Estados][G:o][L:Cadas' /* comment truncated */ /*troEstados][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Cidades`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Cidades` ;

CREATE TABLE IF NOT EXISTS `Cidades` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código que identifica a cidade[G:o]',
  `EstadoID` INT NOT NULL COMMENT 'Informa a qual estado a cidade pertence[N:Estado][G:o]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome da cidade, é único para cada estado[S][N:Nome][G:o]',
  `CEP` VARCHAR(8) NULL DEFAULT NULL COMMENT 'Código dos correios para identificação da cidade[M:99999-999][G:o][N:CEP]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Cidades_Estados_EstadoID_idx` (`EstadoID` ASC),
  UNIQUE INDEX `EstadoID_Nome_UNIQUE` (`EstadoID` ASC, `Nome` ASC),
  UNIQUE INDEX `CEP_UNIQUE` (`CEP` ASC),
  CONSTRAINT `FK_Cidades_Estados_EstadoID`
    FOREIGN KEY (`EstadoID`)
    REFERENCES `Estados` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Cidade de um estado, contém bairros[N:Cidade|Cidades][G:a][' /* comment truncated */ /*L:CadastroCidades][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Bairros`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Bairros` ;

CREATE TABLE IF NOT EXISTS `Bairros` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do bairro[G:o]',
  `CidadeID` INT NOT NULL COMMENT 'Cidade a qual o bairro pertence[N:Cidade][G:a][S:S]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome do bairro[N:Nome][G:o][S]',
  `ValorEntrega` DECIMAL(19,4) NOT NULL COMMENT 'Valor cobrado para entregar um pedido nesse bairro[N:Valor da entrega][G:o]',
  `Disponivel` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o bairro está disponível para entrega de pedidos[N:Disponível][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `CidadeID_Nome_UNIQUE` (`CidadeID` ASC, `Nome` ASC),
  INDEX `FK_Bairros_Cidades_CidadeID_idx` (`CidadeID` ASC),
  CONSTRAINT `FK_Bairros_Cidades_CidadeID`
    FOREIGN KEY (`CidadeID`)
    REFERENCES `Cidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Bairro de uma cidade[N:Bairro|Bairros][G:o][L:CadastroBairro' /* comment truncated */ /*s][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Localizacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Localizacoes` ;

CREATE TABLE IF NOT EXISTS `Localizacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do endereço[G:o]',
  `ClienteID` INT NOT NULL COMMENT 'Cliente a qual esse endereço pertence[N:Cliente][G:o][S:S]',
  `BairroID` INT NOT NULL COMMENT 'Bairro do endereço[N:Bairro][G:o][S:S]',
  `CEP` VARCHAR(8) NULL DEFAULT NULL COMMENT 'Código dos correios para identificar um logradouro[M:99999-999][N:CEP][G:o]',
  `Logradouro` VARCHAR(100) NOT NULL COMMENT 'Nome da rua ou avenida[N:Logradouro][G:o][S]',
  `Numero` VARCHAR(20) NOT NULL COMMENT 'Número da casa ou do condomínio[N:Número][G:o]',
  `Tipo` ENUM('Casa', 'Apartamento') NOT NULL DEFAULT 'Casa' COMMENT 'Tipo de endereço Casa ou Apartamento[N:Tipo][G:o]',
  `Complemento` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Complemento do endereço, Ex.: Loteamento Sul[N:Complemento][G:o]',
  `Condominio` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Nome do condomínio[N:Condomínio][G:o]',
  `Bloco` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Número do bloco quando for apartamento[N:Bloco][G:o]',
  `Apartamento` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Número do apartamento[N:Apartamento][G:o]',
  `Referencia` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Ponto de referência para chegar ao local[N:Referência][G:a]',
  `Latitude` DOUBLE NULL DEFAULT NULL COMMENT 'Ponto latitudinal para localização em um mapa[N:Latitude][G:a]',
  `Longitude` DOUBLE NULL DEFAULT NULL COMMENT 'Ponto longitudinal para localização em um mapa[N:Longitude][G:a]',
  `Apelido` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Ex.: Minha Casa, Casa da Amiga[N:Apelido][G:o]',
  `Mostrar` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Permite esconder ou exibir um endereço do cliente[N:Mostrar][G:o]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Localizacoes_Clientes_ClienteID_ID_idx` (`ClienteID` ASC),
  UNIQUE INDEX `UK_Localizacoes_ClienteID_Apelido` (`ClienteID` ASC, `Apelido` ASC),
  INDEX `FK_Localizacoes_Bairros_idx` (`BairroID` ASC),
  CONSTRAINT `FK_Localizacoes_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Localizacoes_Bairros`
    FOREIGN KEY (`BairroID`)
    REFERENCES `Bairros` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Endereço detalhado de um cliente[N:Localização|Localizaç' /* comment truncated */ /*ões][G:a][L:CadastroClientes][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Comandas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Comandas` ;

CREATE TABLE IF NOT EXISTS `Comandas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Número da comanda[N:Número][G:o]',
  `Nome` VARCHAR(50) NOT NULL COMMENT 'Nome da comanda[N:Nome][G:o][S]',
  `Ativa` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se a comanda está diponível para ser usada nas vendas[N:Ativa][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC))
ENGINE = InnoDB
COMMENT = 'Comanda individual, permite lançar pedidos em cartões de c' /* comment truncated */ /*onsumo[N:Comanda|Comandas][G:a][L:CadastroComandas][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Movimentacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Movimentacoes` ;

CREATE TABLE IF NOT EXISTS `Movimentacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código da movimentação do caixa[G:o]',
  `SessaoID` INT NOT NULL COMMENT 'Sessão do dia, permite abrir vários caixas no mesmo dia com o mesmo código da sessão[N:Sessão][G:a][S:S]',
  `CaixaID` INT NOT NULL COMMENT 'Caixa a qual pertence essa movimentação[N:Caixa][G:o][S]',
  `Aberta` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o caixa está aberto[N:Aberta][G:a]',
  `FuncionarioAberturaID` INT NOT NULL COMMENT 'Funcionário que abriu o caixa[N:Funcionário inicializador][G:a][S:S]',
  `DataAbertura` DATETIME NOT NULL COMMENT 'Data de abertura do caixa[N:Data de abertura][G:a]',
  `FuncionarioFechamentoID` INT NULL DEFAULT NULL COMMENT 'Funcionário que fechou o caixa[N:Funcionário fechador][G:o][S:S]',
  `DataFechamento` DATETIME NULL DEFAULT NULL COMMENT 'Data de fechamento do caixa[N:Data de fechamento][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Movimentacoes_Sessoes_SessaoID_idx` (`SessaoID` ASC),
  INDEX `FK_Movimentacoes_Caixas_CaixaID_idx` (`CaixaID` ASC),
  INDEX `FK_Movimentacoes_Funcionarios_FuncionarioAberturaID_idx` (`FuncionarioAberturaID` ASC),
  INDEX `FK_Movimentacoes_Funcionarios_FuncionarioFechamentoID_idx` (`FuncionarioFechamentoID` ASC),
  CONSTRAINT `FK_Movimentacoes_Sessoes_SessaoID`
    FOREIGN KEY (`SessaoID`)
    REFERENCES `Sessoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Movimentacoes_Caixas_CaixaID`
    FOREIGN KEY (`CaixaID`)
    REFERENCES `Caixas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Movimentacoes_Funcionarios_FuncionarioAberturaID`
    FOREIGN KEY (`FuncionarioAberturaID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Movimentacoes_Funcionarios_FuncionarioFechamentoID`
    FOREIGN KEY (`FuncionarioFechamentoID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Movimentação do caixa, permite abrir diversos caixas na co' /* comment truncated */ /*nta de operadores[N:Movimentação|Movimentações][G:a][L:AbrirCaixa][K:MZ\Session|MZ\Session\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Pedidos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Pedidos` ;

CREATE TABLE IF NOT EXISTS `Pedidos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código do pedido[N:Código][G:o]',
  `MesaID` INT NULL DEFAULT NULL COMMENT 'Identificador da mesa, único quando o pedido não está fechado[N:Mesa][G:a][S:S]',
  `ComandaID` INT NULL DEFAULT NULL COMMENT 'Identificador da comanda, único quando o pedido não está fechado[N:Comanda][G:a][S:S]',
  `MovimentacaoID` INT NULL DEFAULT NULL COMMENT 'Movimentação do caixa quando o pedido é pago total ou parcial, somente um caixa pode receber os pagamentos de um pedido[N:Movimentação][G:a][S:S]',
  `SessaoID` INT NOT NULL COMMENT 'Identificador da sessão de vendas[N:Sessão][G:a][S:S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que criou esse pedido[N:Funcionário][G:o][S:S]',
  `EntregadorID` INT NULL DEFAULT NULL COMMENT 'Entregador que fez a entrega do pedido[N:Entregador][G:o][S:S]',
  `ClienteID` INT NULL DEFAULT NULL COMMENT 'Identificador do cliente do pedido[N:Cliente][G:o][S:S]',
  `LocalizacaoID` INT NULL DEFAULT NULL COMMENT 'Endereço de entrega do pedido, se não informado na venda entrega, o pedido será para viagem[N:Localização][G:a][S:S]',
  `Tipo` ENUM('Mesa', 'Comanda', 'Avulso', 'Entrega') NOT NULL DEFAULT 'Mesa' COMMENT 'Tipo de venda[N:Tipo][G:o][E:Mesa|Comanda|Balcão|Entrega][S:S]',
  `Estado` ENUM('Finalizado', 'Ativo', 'Agendado', 'Entrega', 'Fechado') NOT NULL DEFAULT 'Ativo' COMMENT 'Estado do pedido, Agendado: O pedido deve ser processado na data de agendamento. Ativo: O pedido deve ser processado. Fechado: O cliente pediu a conta e está pronto para pagar. Entrega: O pedido saiu para entrega. Finalizado: O pedido foi pago e concluí' /* comment truncated */ /*do[N:Estado][G:o]*/,
  `Pessoas` INT NOT NULL DEFAULT 1 COMMENT 'Informa quantas pessoas estão na mesa[N:Pessoas][G:a]',
  `Descricao` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Detalhes da reserva ou do pedido[N:Descrição][G:a]',
  `FechadorID` INT NULL DEFAULT NULL COMMENT 'Informa quem fechou o pedido e imprimiu a conta[N:Fechador do pedido][G:o][S:S]',
  `DataImpressao` DATETIME NULL DEFAULT NULL COMMENT 'Data de impressão da conta do cliente[N:Data de impressão][G:a]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o pedido foi cancelado[N:Cancelado][G:o]',
  `Motivo` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Informa o motivo do cancelamento[G:o][N:Motivo]',
  `DataCriacao` DATETIME NOT NULL COMMENT 'Data de criação do pedido[N:Data de criação][G:a]',
  `DataAgendamento` DATETIME NULL DEFAULT NULL COMMENT 'Data de agendamento do pedido[N:Data de agendamento][G:a]',
  `DataEntrega` DATETIME NULL DEFAULT NULL COMMENT 'Data e hora que o entregador saiu para entregar o pedido[N:Data de entrega][G:a]',
  `DataConclusao` DATETIME NULL DEFAULT NULL COMMENT 'Data de finalização do pedido[N:Data de conclusão][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Pedidos_Mesas_MesaID_idx` (`MesaID` ASC),
  INDEX `FK_Pedidos_Sessoes_SessaoID_idx` (`SessaoID` ASC),
  INDEX `FK_Pedidos_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `IDX_Pedidos_MesaID_Estado` (`MesaID` ASC, `Estado` ASC),
  INDEX `FK_Pedidos_Clientes_ClienteID_idx` (`ClienteID` ASC),
  INDEX `IDX_Pedidos_SessaoID_Tipo_Estado` (`SessaoID` ASC, `Tipo` ASC, `Estado` ASC),
  INDEX `FK_Pedidos_Funcionarios_EntregadorID_idx` (`EntregadorID` ASC),
  INDEX `FK_Pedidos_Localizacoes_LocalizacaoID_idx` (`LocalizacaoID` ASC),
  INDEX `FK_Pedidos_Comandas_ComandaID_idx` (`ComandaID` ASC),
  INDEX `FK_Pedidos_Movimentacoes_MovimentacaoID_idx` (`MovimentacaoID` ASC),
  INDEX `FK_Pedidos_Funcionarios_FechadorID_idx` (`FechadorID` ASC),
  INDEX `IDX_Pedidos_ComandaID_Estado` (`ComandaID` ASC, `Estado` ASC),
  CONSTRAINT `FK_Pedidos_Mesas_MesaID`
    FOREIGN KEY (`MesaID`)
    REFERENCES `Mesas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Sessoes_SessaoID`
    FOREIGN KEY (`SessaoID`)
    REFERENCES `Sessoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Funcionarios_EntregadorID`
    FOREIGN KEY (`EntregadorID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Localizacoes_LocalizacaoID`
    FOREIGN KEY (`LocalizacaoID`)
    REFERENCES `Localizacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Comandas_ComandaID`
    FOREIGN KEY (`ComandaID`)
    REFERENCES `Comandas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Movimentacoes_MovimentacaoID`
    FOREIGN KEY (`MovimentacaoID`)
    REFERENCES `Movimentacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pedidos_Funcionarios_FechadorID`
    FOREIGN KEY (`FechadorID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informações do pedido de venda[N:Pedido|Pedidos][G:o][L:Pa' /* comment truncated */ /*gamento][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Categorias`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Categorias` ;

CREATE TABLE IF NOT EXISTS `Categorias` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da categoria[G:o]',
  `CategoriaID` INT NULL DEFAULT NULL COMMENT 'Informa a categoria pai da categoria atual, a categoria atual é uma subcategoria[N:Categoria superior][G:a][S:S]',
  `Descricao` VARCHAR(45) NOT NULL COMMENT 'Descrição da categoria. Ex.: Refrigerantes, Salgados[N:Descrição][G:a][S]',
  `Servico` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se a categoria é destinada para produtos ou serviços[N:Serviço][G:o]',
  `Imagem` MEDIUMBLOB NULL DEFAULT NULL COMMENT 'Imagem representativa da categoria[N:Imagem][G:a][I:256x256|categoria|categoria.png]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização das informações da categoria[N:Data de atualização][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC),
  INDEX `FK_Categorias_Categorias_CategoriaID_idx` (`CategoriaID` ASC),
  CONSTRAINT `FK_Categorias_Categorias_CategoriaID`
    FOREIGN KEY (`CategoriaID`)
    REFERENCES `Categorias` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa qual a categoria dos produtos e permite a rápida lo' /* comment truncated */ /*calização dos mesmos[N:Categoria|Categorias][G:a][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Unidades`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Unidades` ;

CREATE TABLE IF NOT EXISTS `Unidades` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da unidade[G:o]',
  `Nome` VARCHAR(45) NOT NULL COMMENT 'Nome da unidade de medida, Ex.: Grama, Quilo[N:Nome][G:o][S]',
  `Descricao` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Detalhes sobre a unidade de medida[N:Descrição][G:a]',
  `Sigla` VARCHAR(10) NOT NULL COMMENT 'Sigla da unidade de medida, Ex.: UN, L, g[N:Sigla][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Sigla_UNIQUE` (`Sigla` ASC))
ENGINE = InnoDB
COMMENT = 'Unidades de medidas aplicadas aos produtos[N:Unidade|Unidade' /* comment truncated */ /*s][G:a][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Setores`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Setores` ;

CREATE TABLE IF NOT EXISTS `Setores` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do setor[G:o]',
  `Nome` VARCHAR(50) NOT NULL COMMENT 'Nome do setor, único em todo o sistema[N:Nome][G:o][S]',
  `Descricao` VARCHAR(70) NULL DEFAULT NULL COMMENT 'Descreve a utilização do setor[N:Descrição][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC))
ENGINE = InnoDB
COMMENT = 'Setor de impressão e de estoque[N:Setor|Setores][G:o][L:Est' /* comment truncated */ /*oque][K:MZ\Environment|MZ\Environment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Origens`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Origens` ;

CREATE TABLE IF NOT EXISTS `Origens` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da origem[G:o]',
  `Codigo` INT NOT NULL COMMENT 'Código da origem da mercadoria[G:o][N:Código]',
  `Descricao` VARCHAR(200) NOT NULL COMMENT 'Descrição da origem da mercadoria[G:a][N:Descrição]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Codigo_UNIQUE` (`Codigo` ASC))
ENGINE = InnoDB
COMMENT = 'Origem da mercadoria[N:Origem|Origens][G:a][L:CadastroProdut' /* comment truncated */ /*os][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Operacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Operacoes` ;

CREATE TABLE IF NOT EXISTS `Operacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da operação[G:o]',
  `Codigo` INT NOT NULL COMMENT 'Código CFOP sem pontuação[G:o][N:Código]',
  `Descricao` VARCHAR(255) NOT NULL COMMENT 'Descrição da operação[G:a][N:Descrição]',
  `Detalhes` TEXT NULL DEFAULT NULL COMMENT 'Detalhes da operação (Opcional)[G:o][N:Detalhes]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Codigo_UNIQUE` (`Codigo` ASC))
ENGINE = InnoDB
COMMENT = 'Código Fiscal de Operações e Prestações (CFOP)[N:' /* comment truncated */ /*Operação|Operações][G:a][L:CadastroProdutos][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Impostos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Impostos` ;

CREATE TABLE IF NOT EXISTS `Impostos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do imposto[G:o]',
  `Grupo` ENUM('ICMS', 'PIS', 'COFINS', 'IPI', 'II') NOT NULL COMMENT 'Grupo do imposto[G:o][N:Grupo]',
  `Simples` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se o imposto é do simples nacional[G:o][N:Simples nacional]',
  `Substituicao` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se o imposto é por substituição tributária[G:a][N:Substituição tributária]',
  `Codigo` INT NOT NULL COMMENT 'Informa o código do imposto[G:o][N:Código]',
  `Descricao` VARCHAR(255) NOT NULL COMMENT 'Descrição do imposto[G:a][N:Descrição]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `UK_Imposto` (`Grupo` ASC, `Simples` ASC, `Substituicao` ASC, `Codigo` ASC))
ENGINE = InnoDB
COMMENT = 'Impostos disponíveis para informar no produto[N:Imposto|Imp' /* comment truncated */ /*ostos][G:o][L:CadastroProdutos][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Tributacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Tributacoes` ;

CREATE TABLE IF NOT EXISTS `Tributacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da tributação[G:o]',
  `NCM` VARCHAR(10) NOT NULL COMMENT 'Código NCM (Nomenclatura Comum do Mercosul) do produto[G:o][N:NCM]',
  `CEST` VARCHAR(20) NULL DEFAULT NULL COMMENT 'Código CEST do produto (Opcional)[G:o][N:CEST]',
  `OrigemID` INT NOT NULL COMMENT 'Origem do produto[G:a][N:Origem]',
  `OperacaoID` INT NOT NULL COMMENT 'CFOP do produto[G:o][N:CFOP]',
  `ImpostoID` INT NOT NULL COMMENT 'Imposto do produto[G:o][N:Imposto]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Tributacoes_Origens_OrigemID_idx` (`OrigemID` ASC),
  INDEX `FK_Tributacoes_Operacoes_OperacaoID_idx` (`OperacaoID` ASC),
  INDEX `FK_Tributacoes_Impostos_ImpostoID_idx` (`ImpostoID` ASC),
  CONSTRAINT `FK_Tributacoes_Origens_OrigemID`
    FOREIGN KEY (`OrigemID`)
    REFERENCES `Origens` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Tributacoes_Operacoes_OperacaoID`
    FOREIGN KEY (`OperacaoID`)
    REFERENCES `Operacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Tributacoes_Impostos_ImpostoID`
    FOREIGN KEY (`ImpostoID`)
    REFERENCES `Impostos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informação tributária dos produtos[N:Tributação|Tributa' /* comment truncated */ /*ções][G:a][L:CadastroProdutos][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Produtos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Produtos` ;

CREATE TABLE IF NOT EXISTS `Produtos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código do produto[G:o]',
  `CodigoBarras` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Código de barras do produto, deve ser único entre todos os produtos[N:Código de barras][G:o]',
  `CategoriaID` INT NOT NULL COMMENT 'Categoria do produto, permite a rápida localização ao utilizar tablets[N:Categoria][G:a][S:S]',
  `UnidadeID` INT NOT NULL COMMENT 'Informa a unidade do produtos, Ex.: Grama, Litro.[N:Unidade][G:a]',
  `SetorEstoqueID` INT NULL DEFAULT NULL COMMENT 'Informa de qual setor o produto será retirado após a venda[N:Setor de estoque][G:o]',
  `SetorPreparoID` INT NULL DEFAULT NULL COMMENT 'Informa em qual setor de preparo será enviado o ticket de preparo ou autorização, se nenhum for informado nada será impresso[N:Setor de preparo][G:o]',
  `TributacaoID` INT NULL DEFAULT NULL COMMENT 'Informações de tributação do produto[G:a][N:Tributação][S:S]',
  `Descricao` VARCHAR(75) NOT NULL COMMENT 'Descrição do produto, Ex.: Refri. Coca Cola 2L.[N:Descrição][G:a][S]',
  `Abreviacao` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Nome abreviado do produto, Ex.: Cebola, Tomate, Queijo[N:Abreviação][G:a]',
  `Detalhes` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Informa detalhes do produto, Ex: Com Cebola, Pimenta, Orégano[N:Detalhes][G:o]',
  `QuantidadeLimite` DOUBLE NOT NULL COMMENT 'Informa a quantidade limite para que o sistema avise que o produto já está acabando[N:Quantidade limite][G:a]',
  `QuantidadeMaxima` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Informa a quantidade máxima do produto no estoque, não proibe, apenas avisa[N:Quantidade máxima][G:a]',
  `Conteudo` DOUBLE NOT NULL DEFAULT 1 COMMENT 'Informa o conteúdo do produto, Ex.: 2000 para 2L de conteúdo, 200 para 200g de peso ou 1 para 1 unidade[N:Conteúdo][G:o]',
  `PrecoVenda` DECIMAL(19,4) NOT NULL COMMENT 'Preço de venda ou preço de venda base para pacotes[N:Preço de venda][G:o]',
  `CustoProducao` DECIMAL(19,4) NULL DEFAULT NULL COMMENT 'Informa qual o valor para o custo de produção do produto, utilizado quando não há formação de composição do produto[N:Custo de produção][G:o]',
  `Tipo` ENUM('Produto', 'Composicao', 'Pacote') NOT NULL DEFAULT 'Produto' COMMENT 'Informa qual é o tipo de produto. Produto: Produto normal que possui estoque, Composição: Produto que não possui estoque diretamente, pois é composto de outros produtos ou composições, Pacote: Permite a composição no momento da venda, não possui' /* comment truncated */ /* estoque diretamente[N:Tipo][G:o][E:Produto|Composição|Pacote]*/,
  `CobrarServico` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se deve ser cobrado a taxa de serviço dos garçons sobre este produto[N:Cobrança de serviço][G:a]',
  `Divisivel` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o produto pode ser vendido fracionado[N:Divisível][G:o]',
  `Pesavel` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o peso do produto deve ser obtido de uma balança, obrigatoriamente o produto deve ser divisível[N:Pesável][G:o]',
  `Perecivel` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o produto vence em pouco tempo[N:Perecível][G:o]',
  `TempoPreparo` INT NOT NULL DEFAULT 0 COMMENT 'Tempo de preparo em minutos para preparar uma composição, 0 para não informado[N:Tempo de preparo][G:o]',
  `Visivel` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o produto estará disponível para venda[N:Visível][G:o]',
  `Imagem` MEDIUMBLOB NULL DEFAULT NULL COMMENT 'Imagem do produto[N:Imagem][G:a][I:256x256|produto|produto.png]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização das informações do produto[N:Data de atualização][G:a][D]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC),
  UNIQUE INDEX `CodBarras_UNIQUE` (`CodigoBarras` ASC),
  INDEX `FK_Produtos_Categorias_CategoriaID_idx` (`CategoriaID` ASC),
  INDEX `FK_Produtos_Unidades_UnidadeID_idx` (`UnidadeID` ASC),
  INDEX `FK_Produtos_Setores_SetorPreparoID_idx` (`SetorPreparoID` ASC),
  INDEX `FK_Produtos_Setores_SetorEstoqueID_idx` (`SetorEstoqueID` ASC),
  INDEX `FK_Produtos_Tributacoes_TributacaoID_idx` (`TributacaoID` ASC),
  CONSTRAINT `FK_Produtos_Categorias_CategoriaID`
    FOREIGN KEY (`CategoriaID`)
    REFERENCES `Categorias` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Produtos_Unidades_UnidadeID`
    FOREIGN KEY (`UnidadeID`)
    REFERENCES `Unidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Produtos_Setores_SetorPreparoID`
    FOREIGN KEY (`SetorPreparoID`)
    REFERENCES `Setores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Produtos_Setores_SetorEstoqueID`
    FOREIGN KEY (`SetorEstoqueID`)
    REFERENCES `Setores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Produtos_Tributacoes_TributacaoID`
    FOREIGN KEY (`TributacaoID`)
    REFERENCES `Tributacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informações sobre o produto, composição ou pacote[N:Prod' /* comment truncated */ /*uto|Produtos][G:o][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Servicos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Servicos` ;

CREATE TABLE IF NOT EXISTS `Servicos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do serviço[G:o]',
  `Nome` VARCHAR(50) NOT NULL COMMENT 'Nome do serviço, Ex.: Comissão, Entrega, Couvert[N:Nome][G:o]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descrição do serviço, Ex.: Show de fulano[N:Descrição][G:a][S]',
  `Detalhes` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Detalhes do serviço, Ex.: Com participação especial de fulano[N:Detalhes][G:o]',
  `Tipo` ENUM('Evento', 'Taxa') NOT NULL COMMENT 'Tipo de serviço, Evento: Eventos como show no estabelecimento[N:Tipo][G:o]',
  `Obrigatorio` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se a taxa é obrigatória[N:Obrigatório][G:o]',
  `DataInicio` DATETIME NULL DEFAULT NULL COMMENT 'Data de início do evento[N:Data de início][G:a]',
  `DataFim` DATETIME NULL DEFAULT NULL COMMENT 'Data final do evento[N:Data final][G:a]',
  `Valor` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Valor do serviço[N:Valor][G:o]',
  `Individual` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se a taxa ou serviço é individual para cada pessoa[N:Individual][G:o]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o serviço está ativo[N:Ativo][G:o]',
  PRIMARY KEY (`ID`))
ENGINE = InnoDB
COMMENT = 'Taxas, eventos e serviço cobrado nos pedidos[N:Serviço|Ser' /* comment truncated */ /*viços][G:o][L:CadastroServicos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Produtos_Pedidos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Produtos_Pedidos` ;

CREATE TABLE IF NOT EXISTS `Produtos_Pedidos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do item do pedido[G:o]',
  `PedidoID` INT NOT NULL COMMENT 'Pedido a qual pertence esse item[N:Pedido][G:o][S:S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que lançou esse item no pedido[N:Funcionário][G:o][S:S]',
  `ProdutoID` INT NULL COMMENT 'Produto vendido[N:Produto][G:o][S][S:S]',
  `ServicoID` INT NULL DEFAULT NULL COMMENT 'Serviço cobrado ou taxa[N:Serviço][G:o][S:S]',
  `ProdutoPedidoID` INT NULL DEFAULT NULL COMMENT 'Pacote em que esse item faz parte[N:Pacote][G:o][S:S]',
  `Descricao` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Sobrescreve a descrição do produto na exibição[N:Descrição][G:a]',
  `Preco` DECIMAL(19,4) NOT NULL COMMENT 'Preço do produto já com desconto[N:Preço][G:o]',
  `Quantidade` DOUBLE NOT NULL COMMENT 'Quantidade de itens vendidos[N:Quantidade][G:a]',
  `Porcentagem` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Porcentagem cobrada sobre essa venda, escala de 0 a 100[N:Porcentagem][G:a]',
  `PrecoVenda` DECIMAL(19,4) NOT NULL COMMENT 'Preço de normal do produto no momento da venda[N:Preço de venda][G:o]',
  `PrecoCompra` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Preço de compra do produto calculado automaticamente na hora da venda[N:Preço de compra][G:o]',
  `Detalhes` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Observações do item pedido, Ex.: bem gelado, mal passado[N:Observações][G:o]',
  `Estado` ENUM('Adicionado', 'Enviado', 'Processado', 'Pronto', 'Disponivel', 'Entregue') NOT NULL DEFAULT 'Adicionado' COMMENT 'Estado de preparo e envio do produto[N:Estado][G:o][E:Adicionado|Enviado|Processado|Pronto|Disponível|Entregue]',
  `Visualizado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o item foi visualizado por alguém[N:Visualizado][G:o]',
  `DataVisualizacao` DATETIME NULL DEFAULT NULL COMMENT 'Data de visualização do item[N:Data de visualização][G:a]',
  `DataAtualizacao` DATETIME NULL DEFAULT NULL COMMENT 'Data de atualização do estado do item[N:Data de atualização][G:a]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o item foi cancelado[N:Cancelado][G:o]',
  `Motivo` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Informa o motivo do item ser cancelado[N:Motivo][G:o]',
  `Desperdicado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o item foi cancelado por conta de desperdício[N:Desperdiçado][G:o]',
  `DataHora` DATETIME NOT NULL COMMENT 'Data e hora da realização do pedido do item[N:Data e hora][G:a][D]',
  INDEX `FK_ProdPed_Pedidos_PedID_idx` (`PedidoID` ASC),
  INDEX `FK_ProdPed_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  INDEX `FK_ProdPed_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  PRIMARY KEY (`ID`),
  INDEX `IDX_ProdPed_DataHora` (`DataHora` ASC),
  INDEX `FK_ProdPed_ProdPed_ProdutoPedidoID_idx` (`ProdutoPedidoID` ASC),
  INDEX `FK_ProdPed_Servicos_ServicoID_idx` (`ServicoID` ASC),
  CONSTRAINT `FK_ProdPed_Pedidos_PedID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_ProdPed_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_ProdPed_Funcionario_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_ProdPed_ProdPed_ProdutoPedidoID`
    FOREIGN KEY (`ProdutoPedidoID`)
    REFERENCES `Produtos_Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_ProdPed_Servicos_ServicoID`
    FOREIGN KEY (`ServicoID`)
    REFERENCES `Servicos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Produtos, taxas e serviços do pedido, a alteração do esta' /* comment truncated */ /*do permite o controle de produção[N:Item do pedido|Itens do pedido][G:o][L:Pagamento][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Cheques`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Cheques` ;

CREATE TABLE IF NOT EXISTS `Cheques` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do cheque[G:o]',
  `BancoID` INT NOT NULL COMMENT 'Banco do cheque[N:Banco][G:o][S]',
  `Agencia` VARCHAR(45) NOT NULL COMMENT 'Número da agência[N:Agência][G:a]',
  `Conta` VARCHAR(45) NOT NULL COMMENT 'Número da conta do banco descrito no cheque[N:Conta][G:a]',
  `ClienteID` INT NOT NULL COMMENT 'Cliente que emitiu o cheque[N:Cliente][G:o][S:S]',
  `Parcelas` INT NOT NULL COMMENT 'Quantidade de parcelas/folhas de cheque[N:Parcelas][G:a]',
  `Total` DECIMAL(19,4) NOT NULL COMMENT 'Total pago em cheque[N:Total][G:o]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o cheque e todas as suas folhas estão cancelados[N:Cancelado][G:o]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro do cheque[N:Data de cadastro][G:a][D]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Cheques_Bancos_BancoID_idx` (`BancoID` ASC),
  INDEX `FK_Cheques_Clientes_ClienteID_idx` (`ClienteID` ASC),
  CONSTRAINT `FK_Cheques_Bancos_BancoID`
    FOREIGN KEY (`BancoID`)
    REFERENCES `Bancos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Cheques_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Cheques lançados como pagamentos[N:Cheque|Cheques][G:o][L:P' /* comment truncated */ /*agamento][K:MZ\Payment|MZ\Payment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Classificacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Classificacoes` ;

CREATE TABLE IF NOT EXISTS `Classificacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da classificação[G:o]',
  `ClassificacaoID` INT NULL DEFAULT NULL COMMENT 'Classificação superior, quando informado, esta classificação será uma subclassificação[N:Classificação superior][G:a][S:S]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descrição da classificação[N:Descrição][G:a][S]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Descricao_UNIQUE` (`Descricao` ASC),
  INDEX `FK_Classificacoes_ClassificacaoID_idx` (`ClassificacaoID` ASC),
  CONSTRAINT `FK_Classificacoes_ClassificacaoID`
    FOREIGN KEY (`ClassificacaoID`)
    REFERENCES `Classificacoes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Classificação se contas, permite atribuir um grupo de cont' /* comment truncated */ /*as[N:Classificação|Classificações][G:a][L:CadastroContas][K:MZ\Account|MZ\Account\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Contas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Contas` ;

CREATE TABLE IF NOT EXISTS `Contas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Código da conta[G:o]',
  `ClassificacaoID` INT NOT NULL COMMENT 'Classificação da conta[N:Classificação][G:a][S:S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que lançou a conta[N:Funcionário][G:o][S:S]',
  `SubClassificacaoID` INT NULL DEFAULT NULL COMMENT 'Subclassificação da conta[N:Subclassificação][G:a][S:S]',
  `ClienteID` INT NULL DEFAULT NULL COMMENT 'Cliente a qual a conta pertence[N:Cliente][G:o][S:S]',
  `PedidoID` INT NULL DEFAULT NULL COMMENT 'Pedido da qual essa conta foi gerada[N:Pedido][G:o][S:S]',
  `Descricao` VARCHAR(200) NOT NULL COMMENT 'Descrição da conta[N:Descrição][G:a][S]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Valor da conta[N:Valor][G:o]',
  `Acrescimo` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Acréscimo de valores ao total[N:Acréscimo][G:o]',
  `Multa` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Multa em valor em caso atraso[N:Multa][G:a]',
  `Juros` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Juros em caso de atraso, valor de 0 a 1, 1 = 100%[N:Juros][G:o]',
  `AutoAcrescimo` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Calcula o acréscimo automaticamente no pagamento quando a conta está atrasada[N:Acréscimo automático][G:o]',
  `Vencimento` DATETIME NULL DEFAULT NULL COMMENT 'Data de vencimento da conta[N:Data de vencimento][G:a]',
  `DataEmissao` DATETIME NULL DEFAULT NULL COMMENT 'Data de emissão da conta[N:Data de emissão][G:a]',
  `NumeroDoc` VARCHAR(64) NULL DEFAULT NULL COMMENT 'Número do documento que gerou a conta[N:Número do documento][G:o]',
  `AnexoCaminho` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Caminho do anexo da conta[N:Anexo][G:o]',
  `Cancelada` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se a conta foi cancelada[N:Cancelada][G:a]',
  `DataPagamento` DATETIME NULL DEFAULT NULL COMMENT 'Data de pagamento que será atribuida ao pagar a conta[N:Data de pagamento][G:a]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro da conta[N:Data de cadastro][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Contas_Clientes_ClienteID_idx` (`ClienteID` ASC),
  INDEX `FK_Contas_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `FK_Contas_Pedidos_PedidoID_idx` (`PedidoID` ASC),
  INDEX `FK_Contas_Classificacoes_ClassificacaoID_idx` (`ClassificacaoID` ASC),
  INDEX `FK_Contas_Classificacoes_SubClassificacaoID_idx` (`SubClassificacaoID` ASC),
  CONSTRAINT `FK_Contas_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Contas_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Contas_Pedidos_PedidoID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Contas_Classificacoes_ClassificacaoID`
    FOREIGN KEY (`ClassificacaoID`)
    REFERENCES `Classificacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Contas_Classificacoes_SubClassificacaoID`
    FOREIGN KEY (`SubClassificacaoID`)
    REFERENCES `Classificacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Contas a pagar e ou receber[N:Conta|Contas][G:a][L:CadastroC' /* comment truncated */ /*ontas][K:MZ\Account|MZ\Account\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Creditos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Creditos` ;

CREATE TABLE IF NOT EXISTS `Creditos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do crédito[G:o]',
  `ClienteID` INT NOT NULL COMMENT 'Cliente a qual o crédito pertence[N:Cliente][G:o][S:S]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Valor do crédito[N:Valor][G:o]',
  `Detalhes` VARCHAR(255) NULL COMMENT 'Detalhes do crédito, justificativa do crédito[N:Detalhes][G:o][S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que cadastrou o crédito[N:Funcionário][G:o][S:S]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o crédito foi cancelado[N:Cancelado][G:o]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro do crédito[N:Data de cadastro][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Creditos_Clientes_ClienteID_idx` (`ClienteID` ASC),
  INDEX `FK_Creditos_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  CONSTRAINT `FK_Creditos_Clientes_ClienteID`
    FOREIGN KEY (`ClienteID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Creditos_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Créditos de clientes[N:Crédito|Créditos][G:o][L:Cadastrar' /* comment truncated */ /*Creditos][K:MZ\Account|MZ\Account\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Pagamentos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Pagamentos` ;

CREATE TABLE IF NOT EXISTS `Pagamentos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do pagamento[G:o]',
  `CarteiraID` INT NOT NULL COMMENT 'Carteira de destino do valor[N:Carteira][G:a]',
  `MovimentacaoID` INT NULL DEFAULT NULL COMMENT 'Movimentação do caixa quando for pagamento de pedido ou quando a conta for paga do caixa[N:Movimentação][G:a][S:S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que lançou o pagamento no sistema[N:Funcionário][G:o][S:S]',
  `FormaPagtoID` INT NOT NULL COMMENT 'Forma da pagamento do pedido ou conta[N:Forma de pagamento][G:a][S]',
  `PedidoID` INT NULL DEFAULT NULL COMMENT 'Pedido que foi pago[N:Pedido][G:o][S:S]',
  `PagtoContaID` INT NULL DEFAULT NULL COMMENT 'Conta que foi paga/recebida[N:Conta][G:a][S:S]',
  `CartaoID` INT NULL DEFAULT NULL COMMENT 'Cartão em que foi pago, para forma de pagamento em cartão[N:Cartão][G:o]',
  `ChequeID` INT NULL DEFAULT NULL COMMENT 'Cheque em que foi pago[N:Cheque][G:o][S:S]',
  `ContaID` INT NULL DEFAULT NULL COMMENT 'Conta que foi utilizada como pagamento do pedido[N:Conta pedido][G:a][S:S]',
  `CreditoID` INT NULL DEFAULT NULL COMMENT 'Crédito que foi utilizado para pagar o pedido[N:Crédito][G:o][S:S]',
  `Total` DECIMAL(19,4) NOT NULL COMMENT 'Total do pagamento, não inclui juros, negativo para trocos e pagamento de contas[N:Total][G:o]',
  `Parcelas` INT NOT NULL COMMENT 'Quantidade de parcelas quando pagamento parcelado[N:Parcelas][G:a]',
  `ValorParcela` DECIMAL(19,4) NOT NULL COMMENT 'Valor da parcela em caso de parcelamento[N:Valor da parcela][G:o]',
  `Taxas` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Total de taxas cobrada por financeiras e outros (Não negativo)[N:Taxas][G:a]',
  `Detalhes` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Detalhes do pagamento[N:Detalhes][G:o]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o pagamento foi cancelado[N:Cancelado][G:o]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o pagamento está efetivado(Sim) ou apenas foi lançado(Não)[N:Ativo][G:o]',
  `DataCompensacao` DATETIME NOT NULL COMMENT 'Data de compensação do pagamento[N:Data de compensação][G:a]',
  `DataHora` DATETIME NOT NULL COMMENT 'Data de hora do lançamento do pagamento[N:Data de hora][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Pagamentos_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `FK_Pagamentos_Formas_Pagto_FormaPagtoID_idx` (`FormaPagtoID` ASC),
  INDEX `FK_Pagamentos_Pedidos_PedidoID_idx` (`PedidoID` ASC),
  INDEX `FK_Pagamentos_Cartoes_CartaoID_idx` (`CartaoID` ASC),
  INDEX `FK_Pagamentos_Cheques_ChequeID_idx` (`ChequeID` ASC),
  INDEX `FK_Pagamentos_Contas_ContaID_idx` (`ContaID` ASC),
  INDEX `FK_Pagamentos_Contas_PagtoContaID_idx` (`PagtoContaID` ASC),
  INDEX `FK_Pagamentos_Movimentacoes_MovimentacaoID_idx` (`MovimentacaoID` ASC),
  INDEX `FK_Pagamentos_Creditos_CreditoID_idx` (`CreditoID` ASC),
  INDEX `FK_Pagamentos_Carteiras_CarteiraID_idx` (`CarteiraID` ASC),
  CONSTRAINT `FK_Pagamentos_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Formas_Pagto_FormaPagtoID`
    FOREIGN KEY (`FormaPagtoID`)
    REFERENCES `Formas_Pagto` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Pedidos_PedidoID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Cartoes_CartaoID`
    FOREIGN KEY (`CartaoID`)
    REFERENCES `Cartoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Cheques_ChequeID`
    FOREIGN KEY (`ChequeID`)
    REFERENCES `Cheques` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Contas_ContaID`
    FOREIGN KEY (`ContaID`)
    REFERENCES `Contas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Contas_PagtoContaID`
    FOREIGN KEY (`PagtoContaID`)
    REFERENCES `Contas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Movimentacoes_MovimentacaoID`
    FOREIGN KEY (`MovimentacaoID`)
    REFERENCES `Movimentacoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Carteiras_CarteiraID`
    FOREIGN KEY (`CarteiraID`)
    REFERENCES `Carteiras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pagamentos_Creditos_CreditoID`
    FOREIGN KEY (`CreditoID`)
    REFERENCES `Creditos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Pagamentos de contas e pedidos[N:Pagamento|Pagamentos][G:o][' /* comment truncated */ /*L:Pagamento][K:MZ\Payment|MZ\Payment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Auditoria`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Auditoria` ;

CREATE TABLE IF NOT EXISTS `Auditoria` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da auditoria[G:o]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que exerceu a atividade[N:Funcionário][G:o][S:S]',
  `AutorizadorID` INT NOT NULL COMMENT 'Funcionário que autorizou o acesso ao recurso descrito[N:Autorizador][G:o][S:S]',
  `Tipo` ENUM('Financeiro', 'Administrativo') NOT NULL COMMENT 'Tipo de atividade exercida[N:Tipo][G:o][S:S]',
  `Prioridade` ENUM('Baixa', 'Media', 'Alta') NOT NULL COMMENT 'Prioridade de acesso do recurso[N:Prioridade][G:a][E:Baixa|Média|Alta][S:S]',
  `Descricao` VARCHAR(255) NOT NULL COMMENT 'Descrição da atividade exercida[N:Descrição][G:a][S]',
  `DataHora` DATETIME NOT NULL COMMENT 'Data e hora do ocorrido[N:Data e hora][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Auditoria_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `IDX_Auditoria_Prioridade` (`Prioridade` ASC),
  INDEX `IDX_Auditoria_Tipo` (`Tipo` ASC),
  INDEX `IDX_Auditoria_DataHora` (`DataHora` ASC),
  INDEX `FK_Auditoria_Funcionarios_AutorizadorID_idx` (`AutorizadorID` ASC),
  CONSTRAINT `FK_Auditoria_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Auditoria_Funcionarios_AutorizadorID`
    FOREIGN KEY (`AutorizadorID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Registra todas as atividades importantes do sistema[N:Audito' /* comment truncated */ /*ria|Auditorias][G:a][L:RelatorioAuditoria][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Folhas_Cheques`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Folhas_Cheques` ;

CREATE TABLE IF NOT EXISTS `Folhas_Cheques` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da folha de cheque[G:o]',
  `ChequeID` INT NOT NULL COMMENT 'Cheque a qual pertence esssa folha[N:Cheque][G:o][S:S]',
  `Compensacao` VARCHAR(10) NOT NULL COMMENT 'Número de compensação do cheque[N:Compensação][G:a]',
  `Numero` VARCHAR(20) NOT NULL COMMENT 'Número da folha do cheque[N:Número][G:o][S]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Valor na folha do cheque[N:Valor][G:o]',
  `Vencimento` DATETIME NOT NULL COMMENT 'Data de vencimento do cheque[N:Vencimento][G:o]',
  `C1` INT NOT NULL COMMENT 'C1 do cheque[N:C1][G:o]',
  `C2` INT NOT NULL COMMENT 'C2 do cheque[N:C2][G:o]',
  `C3` INT NOT NULL COMMENT 'C3 do cheque[N:C3][G:o]',
  `Serie` VARCHAR(10) NULL DEFAULT NULL COMMENT 'Número de série do cheque[N:Série][G:a]',
  `Recolhido` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o cheque foi recolhido no banco[N:Recolhido][G:o]',
  `Recolhimento` DATETIME NULL DEFAULT NULL COMMENT 'Data de recolhimento do cheque[N:Data de recolhimento][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `UK_Folhas_Cheques_ChequeID_Numero` (`ChequeID` ASC, `Numero` ASC),
  INDEX `FK_Folhas_Cheques_Cheques_ChequeID_idx` (`ChequeID` ASC),
  INDEX `IDX_Folhas_Cheques_Vencimento_Recolhido` (`Vencimento` ASC, `Recolhido` ASC),
  CONSTRAINT `FK_Folhas_Cheques_Cheques_ChequeID`
    FOREIGN KEY (`ChequeID`)
    REFERENCES `Cheques` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Folhas de cheque de um pagamento[N:Folha de cheque|Folhas de' /* comment truncated */ /* cheques][G:a][L:Pagamento][K:MZ\Payment|MZ\Payment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Composicoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Composicoes` ;

CREATE TABLE IF NOT EXISTS `Composicoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da composição[G:o]',
  `ComposicaoID` INT NOT NULL COMMENT 'Informa a qual produto pertence essa composição, deve sempre ser um produto do tipo Composição[N:Composição][G:a][S:S]',
  `ProdutoID` INT NOT NULL COMMENT 'Produto ou composição que faz parte dessa composição, Obs: Não pode ser um pacote[N:Produto da composição][G:o][S]',
  `Tipo` ENUM('Composicao', 'Opcional', 'Adicional') NOT NULL DEFAULT 'Composicao' COMMENT 'Tipo de composição, \'Composicao\' sempre retira do estoque, \'Opcional\' permite desmarcar na venda, \'Adicional\' permite adicionar na venda[N:Tipo][G:o][E:Composição|Opcional|Adicional]',
  `Quantidade` DOUBLE NOT NULL COMMENT 'Quantidade que será consumida desse produto para cada composição formada[N:Quantidade][G:a]',
  `Valor` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Desconto que será realizado ao retirar esse produto da composição no  momento da venda[N:Valor][G:o]',
  `Ativa` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Indica se a composição está sendo usada atualmente na composição do produto[N:Ativa][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Composicoes_Produtos_ComposicaoID_idx` (`ComposicaoID` ASC),
  INDEX `FK_Composicoes_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  UNIQUE INDEX `UK_Composicoes_ComposicaoID_ProdutoID_Tipo` (`ComposicaoID` ASC, `ProdutoID` ASC, `Tipo` ASC),
  CONSTRAINT `FK_Composicoes_Produtos_ComposicaoID`
    FOREIGN KEY (`ComposicaoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Composicoes_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa as propriedades da composição de um produto compos' /* comment truncated */ /*to[N:Composição|Composições][G:a][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Fornecedores`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Fornecedores` ;

CREATE TABLE IF NOT EXISTS `Fornecedores` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do fornecedor[G:o]',
  `EmpresaID` INT NOT NULL COMMENT 'Empresa do fornecedor[N:Empresa][G:a][S]',
  `PrazoPagamento` INT NOT NULL DEFAULT 0 COMMENT 'Prazo em dias para pagamento do fornecedor[N:Prazo de pagamento][G:o]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro do fornecedor[N:Data de cadastro][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Fornecedores_Clientes_EmpresaID_idx` (`EmpresaID` ASC),
  UNIQUE INDEX `EmpresaID_UNIQUE` (`EmpresaID` ASC),
  CONSTRAINT `FK_Fornecedores_Clientes_EmpresaID`
    FOREIGN KEY (`EmpresaID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Fornecedores de produtos[N:Fornecedor|Fornecedores][G:o][L:C' /* comment truncated */ /*adastroFornecedores][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Estoque`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Estoque` ;

CREATE TABLE IF NOT EXISTS `Estoque` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da entrada no estoque[G:o]',
  `ProdutoID` INT NOT NULL COMMENT 'Produto que entrou no estoque[N:Produto][G:o][S][S:S]',
  `TransacaoID` INT NULL DEFAULT NULL COMMENT 'Identificador do item que gerou a saída desse produto do estoque[N:Transação][G:a][S:S]',
  `EntradaID` INT NULL DEFAULT NULL COMMENT 'Informa de qual entrada no estoque essa saída foi retirada, permite estoque FIFO[N:Entrada][G:a][S:S]',
  `FornecedorID` INT NULL DEFAULT NULL COMMENT 'Fornecedor do produto[N:Fornecedor][G:o][S:S]',
  `SetorID` INT NOT NULL COMMENT 'Setor de onde o produto foi inserido ou retirado[N:Setor][G:o]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que inseriu/retirou o produto do estoque[N:Funcionário][G:o][S:S]',
  `TipoMovimento` ENUM('Entrada', 'Venda', 'Consumo', 'Transferencia') NOT NULL COMMENT 'Tipo de movimentação do estoque. Entrada: Entrada de produtos no estoque, Venda: Saída de produtos através de venda, Consumo: Saída de produtos por consumo próprio, Transferência: Indica a transferência de produtos entre setores[N:Tipo de moviment' /* comment truncated */ /*o][G:o][E:Entrada|Venda|Consumo|Transferência][S:S]*/,
  `Quantidade` DOUBLE NOT NULL COMMENT 'Quantidade do mesmo produto inserido no estoque[N:Quantidade][G:a]',
  `PrecoCompra` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Preço de compra do produto[N:Preço de compra][G:o]',
  `Lote` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Lote de produção do produto comprado[N:Lote][G:o]',
  `DataFabricacao` DATETIME NULL DEFAULT NULL COMMENT 'Data de fabricação do produto[N:Data de fabricação][G:a]',
  `DataVencimento` DATETIME NULL DEFAULT NULL COMMENT 'Data de vencimento do produto[N:Data de vencimento][G:a]',
  `Detalhes` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Detalhes da inserção ou retirada do estoque[N:Detalhes][G:o]',
  `Cancelado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa a entrada ou saída do estoque foi cancelada[N:Cancelado][G:o]',
  `DataMovimento` DATETIME NOT NULL COMMENT 'Data de entrada ou saída do produto do estoque[N:Data de movimento][G:a][D]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Estoque_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  INDEX `FK_Estoque_ProdutosPedidos_ID_idx` (`TransacaoID` ASC),
  INDEX `FK_Estoque_Fornecedores_FornecedorID_idx` (`FornecedorID` ASC),
  INDEX `FK_Estoque_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `FK_Estoque_Setores_SetorID_idx` (`SetorID` ASC),
  INDEX `FK_Estoque_Estoque_EntradaID_idx` (`EntradaID` ASC),
  CONSTRAINT `FK_Estoque_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Estoque_ProdutosPedidos_TransacaoID`
    FOREIGN KEY (`TransacaoID`)
    REFERENCES `Produtos_Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Estoque_Fornecedores_FornecedorID`
    FOREIGN KEY (`FornecedorID`)
    REFERENCES `Fornecedores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Estoque_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Estoque_Setores_SetorID`
    FOREIGN KEY (`SetorID`)
    REFERENCES `Setores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Estoque_Estoque_EntradaID`
    FOREIGN KEY (`EntradaID`)
    REFERENCES `Estoque` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Estoque de produtos por setor[N:Estoque|Estoques][G:o][L:Est' /* comment truncated */ /*oque][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Grupos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Grupos` ;

CREATE TABLE IF NOT EXISTS `Grupos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do grupo[G:o]',
  `ProdutoID` INT NOT NULL COMMENT 'Informa o pacote base da formação[N:Pacote][G:o][S:S]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descrição do grupo da formação, Exemplo: Tamanho, Sabores[N:Descrição][G:a][S]',
  `Multiplo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se é possível selecionar mais de um produto ou opção do produto[N:Múltiplo][G:o]',
  `Tipo` ENUM('Inteiro', 'Fracionado') NOT NULL DEFAULT 'Inteiro' COMMENT ' Informa se a formação final será apenas uma unidade ou vários itens[N:Tipo][G:o]',
  `QuantidadeMinima` INT NOT NULL DEFAULT 1 COMMENT 'Permite definir uma quantidade mínima obrigatória para continuar com a venda[N:Quantidade mínima][G:a]',
  `QuantidadeMaxima` INT NOT NULL DEFAULT 0 COMMENT 'Define a quantidade máxima de itens que podem ser escolhidos[N:Quantidade máxima][G:a]',
  `Funcao` ENUM('Minimo', 'Media', 'Maximo', 'Soma') NOT NULL DEFAULT 'Soma' COMMENT 'Informa qual será a fórmula de cálculo do preço, Mínimo: obtém o menor preço, Média:  define o preço do produto como a média dos itens selecionados, Máximo: Obtém o preço do item mais caro do grupo, Soma: Soma todos os preços dos produtos se' /* comment truncated */ /*lecionados[N:Função de preço][G:a][E:Mínimo|Média|Máximo|Soma]*/,
  PRIMARY KEY (`ID`),
  INDEX `FK_Grupos_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  UNIQUE INDEX `UK_Grupos_Produto_Descricao` (`ProdutoID` ASC, `Descricao` ASC),
  CONSTRAINT `FK_Grupos_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Grupos de pacotes, permite criar grupos como Tamanho, Sabore' /* comment truncated */ /*s para formações de produtos[N:Grupo|Grupos][G:o][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Propriedades`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Propriedades` ;

CREATE TABLE IF NOT EXISTS `Propriedades` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da propriedade[G:o]',
  `GrupoID` INT NOT NULL COMMENT 'Grupo que possui essa propriedade como item de um pacote[N:Grupo][G:o][S:S]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome da propriedade, Ex.: Grande, Pequena[N:Nome][G:o][S]',
  `Abreviacao` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Abreviação do nome da propriedade, Ex.: G para Grande, P para Pequena, essa abreviação fará parte do nome do produto[N:Abreviação][G:a]',
  `Imagem` MEDIUMBLOB NULL DEFAULT NULL COMMENT 'Imagem que representa a propriedade[N:Imagem][G:a][I:256x256|propriedade|propriedade.png]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização dos dados ou da imagem da propriedade[N:Data de atualização][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `GrupoID_Nome_UNIQUE` (`GrupoID` ASC, `Nome` ASC),
  INDEX `FK_Propriedades_Grupos_GrupoID_idx` (`GrupoID` ASC),
  CONSTRAINT `FK_Propriedades_Grupos_GrupoID`
    FOREIGN KEY (`GrupoID`)
    REFERENCES `Grupos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa tamanhos de pizzas e opções de peso do produto[N:P' /* comment truncated */ /*ropriedade|Propriedades][G:a][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Pacotes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Pacotes` ;

CREATE TABLE IF NOT EXISTS `Pacotes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do pacote[G:o]',
  `PacoteID` INT NOT NULL COMMENT 'Pacote a qual pertence as informações de formação do produto final[N:Pacote][G:o][S:S]',
  `GrupoID` INT NOT NULL COMMENT 'Grupo de formação, Ex.: Tamanho, Sabores e Complementos.[N:Grupo][G:o][S:S]',
  `ProdutoID` INT NULL DEFAULT NULL COMMENT 'Produto selecionável do grupo. Não pode conter propriedade.[N:Produto][G:o][S][S:S]',
  `PropriedadeID` INT NULL DEFAULT NULL COMMENT 'Propriedade selecionável do grupo. Não pode conter produto.[N:Propriedade][G:a]',
  `AssociacaoID` INT NULL DEFAULT NULL COMMENT 'Informa a propriedade pai de um complemento, permite atribuir preços diferentes dependendo da propriedade, Ex.: Tamanho -> Sabor, onde Tamanho é pai de Sabor[N:Associação][G:a]',
  `QuantidadeMinima` INT NOT NULL DEFAULT 0 COMMENT 'Permite definir uma quantidade mínima obrigatória para a venda desse item[N:Quantidade mínima][G:a][F:0]',
  `QuantidadeMaxima` INT NOT NULL DEFAULT 1 COMMENT 'Define a quantidade máxima que pode ser vendido esse item repetidamente[N:Quantidade máxima][G:a][F:1]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Valor acrescentado ao produto quando o item é selecionado[N:Valor][G:o]',
  `Selecionado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se o complemento está selecionado por padrão, recomendado apenas para produtos[N:Selecionado][G:o][F:\'N\']',
  `Visivel` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Indica se o pacote estará disponível para venda[N:Visível][G:o][F:\'Y\']',
  PRIMARY KEY (`ID`),
  INDEX `FK_Pacotes_Produtos_PacoteID_idx` (`PacoteID` ASC),
  INDEX `FK_Pacotes_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  INDEX `FK_Pacotes_Grupos_GrupoID_idx` (`GrupoID` ASC),
  INDEX `FK_Pacotes_Pacotes_AssociacaoID_idx` (`AssociacaoID` ASC),
  INDEX `FK_Pacotes_Propriedades_PropriedadeID_idx` (`PropriedadeID` ASC),
  CONSTRAINT `FK_Pacotes_Produtos_PacoteID`
    FOREIGN KEY (`PacoteID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pacotes_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pacotes_Grupos_GrupoID`
    FOREIGN KEY (`GrupoID`)
    REFERENCES `Grupos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pacotes_Pacotes_AssociacaoID`
    FOREIGN KEY (`AssociacaoID`)
    REFERENCES `Pacotes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Pacotes_Propriedades_PropriedadeID`
    FOREIGN KEY (`PropriedadeID`)
    REFERENCES `Propriedades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Contém todos as opções para a formação do produto final' /* comment truncated */ /*[N:Pacote|Pacotes][G:o][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Dispositivos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Dispositivos` ;

CREATE TABLE IF NOT EXISTS `Dispositivos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do dispositivo[G:o]',
  `SetorID` INT NOT NULL COMMENT 'Setor em que o dispositivo está instalado/será usado[N:Setor][G:o]',
  `CaixaID` INT NULL DEFAULT NULL COMMENT 'Finalidade do dispositivo, caixa ou terminal, o caixa é único entre os dispositivos[N:Caixa][G:o]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome do computador ou tablet em rede, único entre os dispositivos[N:Nome][G:o][S]',
  `Tipo` ENUM('Computador', 'Tablet') NOT NULL DEFAULT 'Computador' COMMENT 'Tipo de dispositivo[N:Tipo][G:o][S:S]',
  `Descricao` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Descrição do dispositivo[N:Descrição][G:a]',
  `Opcoes` INT NOT NULL DEFAULT 0 COMMENT 'Opções do dispositivo, Ex.: Balança, identificador de chamadas e outros[N:Opções][G:a]',
  `Serial` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Serial do tablet para validação, único entre os dispositivos[N:Serial][G:o]',
  `Validacao` VARCHAR(40) NULL DEFAULT NULL COMMENT 'Validação do tablet[N:Validação][G:a]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC),
  INDEX `FK_Dispositivos_Setores_SetorID_idx` (`SetorID` ASC),
  INDEX `FK_Dispositivos_Caixas_CaixaID_idx` (`CaixaID` ASC),
  UNIQUE INDEX `CaixaID_UNIQUE` (`CaixaID` ASC),
  UNIQUE INDEX `Serial_UNIQUE` (`Serial` ASC),
  CONSTRAINT `FK_Dispositivos_Setores_SetorID`
    FOREIGN KEY (`SetorID`)
    REFERENCES `Setores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Dispositivos_Caixas_CaixaID`
    FOREIGN KEY (`CaixaID`)
    REFERENCES `Caixas` (`ID`)
    ON DELETE SET NULL
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Computadores e tablets com opções de acesso[N:Dispositivo|' /* comment truncated */ /*Dispositivos][G:o][L:CadastroComputadores][K:MZ\Device|MZ\Device\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Impressoras`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Impressoras` ;

CREATE TABLE IF NOT EXISTS `Impressoras` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da impressora[G:o]',
  `SetorID` INT NOT NULL COMMENT 'Setor de impressão[N:Setor de impressão][G:o]',
  `DispositivoID` INT NULL DEFAULT NULL COMMENT 'Dispositivo que contém a impressora[N:Dispositivo][G:o]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome da impressora instalada no windows[N:Nome][G:o]',
  `Driver` VARCHAR(45) NULL DEFAULT NULL COMMENT 'Informa qual conjunto de comandos deve ser utilizado[N:Driver][G:o]',
  `Descricao` VARCHAR(45) NOT NULL DEFAULT '' COMMENT 'Descrição da impressora[N:Descrição][G:a][S]',
  `Modo` ENUM('Terminal', 'Caixa', 'Servico', 'Estoque') NOT NULL DEFAULT 'Terminal' COMMENT 'Modo de impressão[N:Modo][G:o][E:Terminal|Caixa|Serviço|Estoque]',
  `Opcoes` INT NOT NULL DEFAULT 1 COMMENT 'Opções da impressora, Ex.: Cortar papel, Acionar gaveta e outros[N:Opções][G:a]',
  `Colunas` INT NOT NULL DEFAULT 48 COMMENT 'Quantidade de colunas do cupom[N:Quantidade de colunas][G:a]',
  `Avanco` INT NOT NULL DEFAULT 6 COMMENT 'Quantidade de linhas para avanço do papel[N:Avanço de papel][G:o]',
  `Comandos` TEXT NULL DEFAULT NULL COMMENT 'Comandos para impressão, quando o driver é customizado[N:Comandos][G:o]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Impressoras_Dispositivos_DispositivoID_idx` (`DispositivoID` ASC),
  UNIQUE INDEX `UK_Impresoras_Setor_Dispositivo_Modo` (`SetorID` ASC, `DispositivoID` ASC, `Modo` ASC),
  INDEX `FK_Impressoras_Setores_SetorID_idx` (`SetorID` ASC),
  UNIQUE INDEX `UK_Impressoras_Dispositivo_Descricao` (`DispositivoID` ASC, `Descricao` ASC),
  CONSTRAINT `FK_Impressoras_Dispositivos_DispositivoID`
    FOREIGN KEY (`DispositivoID`)
    REFERENCES `Dispositivos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Impressoras_Setores_SetorID`
    FOREIGN KEY (`SetorID`)
    REFERENCES `Setores` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Impressora para impressão de serviços e contas[N:Impressor' /* comment truncated */ /*a|Impressoras][G:a][L:CadastroImpressoras][K:MZ\Device|MZ\Device\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Promocoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Promocoes` ;

CREATE TABLE IF NOT EXISTS `Promocoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da promoção[G:o]',
  `ProdutoID` INT NOT NULL COMMENT 'Informa qual o produto que possui desconto ou acréscimo[N:Produto][G:o][S]',
  `Inicio` INT NOT NULL COMMENT 'Dia inicial em que o produto começa a sofrer alteração de preço[N:Dia inicial][G:o]',
  `Fim` INT NOT NULL COMMENT 'Dia final em que o produto deixará de estar na promoção[N:Dia final][G:o]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Acréscimo ou desconto aplicado ao produto produto[N:Valor][G:o]',
  `Proibir` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se deve proibir a venda desse produto no período informado[N:Proibir a venda][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Promocoes_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  CONSTRAINT `FK_Promocoes_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa se há descontos nos produtos em determinados dias d' /* comment truncated */ /*a semana, o preço pode subir ou descer[N:Promoção|Promoções][G:a][L:CadastroProdutos][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Funcionalidades`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Funcionalidades` ;

CREATE TABLE IF NOT EXISTS `Funcionalidades` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da funcionalidade[G:o]',
  `Nome` VARCHAR(64) NOT NULL COMMENT 'Nome da funcionalidade, único em todo o sistema[N:Nome][G:o]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descrição da funcionalidade[N:Descrição][G:a][S]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC))
ENGINE = InnoDB
COMMENT = 'Grupo de funcionalidades do sistema[N:Funcionalidade|Funcion' /* comment truncated */ /*alidades][G:a][L:AlterarConfiguracoes][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Permissoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Permissoes` ;

CREATE TABLE IF NOT EXISTS `Permissoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da permissão[G:o]',
  `FuncionalidadeID` INT NOT NULL COMMENT 'Categoriza um grupo de permissões[N:Funcionalidade][G:a][S:S]',
  `Nome` VARCHAR(45) NOT NULL COMMENT 'Nome da permissão, único no sistema[N:Nome][G:a]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Descreve a permissão[N:Descrição][G:a][S]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC),
  INDEX `FK_Permissoes_Funcionalidades_FuncionalidadeID_idx` (`FuncionalidadeID` ASC),
  CONSTRAINT `FK_Permissoes_Funcionalidades_FuncionalidadeID`
    FOREIGN KEY (`FuncionalidadeID`)
    REFERENCES `Funcionalidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa a listagem de todas as funções do sistema [N:Permi' /* comment truncated */ /*ssão|Permissões][G:a][L:AlterarConfiguracoes][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Acessos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Acessos` ;

CREATE TABLE IF NOT EXISTS `Acessos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do acesso[G:o]',
  `FuncaoID` INT NOT NULL COMMENT 'Função a que a permissão se aplica[N:Função][G:a][S:S]',
  `PermissaoID` INT NOT NULL COMMENT 'Permissão liberada para a função[N:Permissão][G:a][S]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Acessos_Funcoes_FuncaoID_idx` (`FuncaoID` ASC),
  INDEX `FK_Acessos_Permissoes_PermissaoID_idx` (`PermissaoID` ASC),
  UNIQUE INDEX `UK_Acessos_FuncaoID_PermissaoID` (`FuncaoID` ASC, `PermissaoID` ASC),
  CONSTRAINT `FK_Acessos_Funcoes_FuncaoID`
    FOREIGN KEY (`FuncaoID`)
    REFERENCES `Funcoes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Acessos_Permissoes_PermissaoID`
    FOREIGN KEY (`PermissaoID`)
    REFERENCES `Permissoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Permite acesso à uma determinada funcionalidade da lista de' /* comment truncated */ /* permissões[N:Acesso|Acessos][G:o][L:AlterarConfiguracoes][K:MZ\Employee|MZ\Employee\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Catalogos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Catalogos` ;

CREATE TABLE IF NOT EXISTS `Catalogos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do catálogo[G:o]',
  `ProdutoID` INT NOT NULL COMMENT 'Produto consultado[N:Produto][G:o][S]',
  `FornecedorID` INT NOT NULL COMMENT 'Fornecedor que possui o produto à venda[N:Fornecedor][G:o][S:S]',
  `PrecoCompra` DECIMAL(19,4) NOT NULL COMMENT 'Preço a qual o produto foi comprado da última vez[N:Preço de compra][G:o]',
  `PrecoVenda` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Preço de venda do produto pelo fornecedor na última consulta[N:Preço de venda][G:o]',
  `QuantidadeMinima` DOUBLE NOT NULL DEFAULT 1 COMMENT 'Quantidade mínima que o fornecedor vende[N:Quantidade mínima][G:a]',
  `Estoque` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Quantidade em estoque do produto no fornecedor[N:Estoque][G:o]',
  `Limitado` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se a quantidade de estoque é limitada[N:Limitado][G:o]',
  `DataConsulta` DATETIME NULL DEFAULT NULL COMMENT 'Última data de consulta do preço do produto[N:Data de consulta][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Catalogos_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  INDEX `FK_Catalogos_Fornecedores_FornecedorID_idx` (`FornecedorID` ASC),
  CONSTRAINT `FK_Catalogos_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Catalogos_Fornecedores_FornecedorID`
    FOREIGN KEY (`FornecedorID`)
    REFERENCES `Fornecedores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa a lista de produtos disponíveis nos fornecedores[N:' /* comment truncated */ /*Catálogo de produtos|Catálogos de produtos][G:o][L:CadastroFornecedores][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Sistema`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Sistema` ;

CREATE TABLE IF NOT EXISTS `Sistema` (
  `ID` ENUM('1') NOT NULL COMMENT 'Identificador único do sistema, valor 1[G:o]',
  `PaisID` INT NULL DEFAULT NULL COMMENT 'País em que o sistema está sendo utilizado[N:País][G:o]',
  `EmpresaID` INT NULL DEFAULT NULL COMMENT 'Informa qual a empresa que gerencia o sistema, a empresa deve ser um cliente do tipo pessoa jurídica[N:Empresa][G:a][S:S]',
  `ParceiroID` INT NULL DEFAULT NULL COMMENT 'Informa quem realiza o suporte do sistema, deve ser um cliente do tipo empresa que possua um acionista como representante[N:Parceiro][G:o][S:S]',
  `AccessKey` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Chave de acesso ao sistema, a chave é atualizada sempre ao utilizar o programa[N:Chave de acesso][G:a]',
  `RegistryKey` TEXT NULL DEFAULT NULL COMMENT 'Chave de registro, permite licenças do tipo aluguel[N:Chave de registro][G:a]',
  `LicenseKey` TEXT NULL DEFAULT NULL COMMENT 'Chave da Licença, permite licença do tipo vitalícia[N:Chave de licença][G:a]',
  `Computadores` INT NULL DEFAULT NULL COMMENT 'Quantidade de computadores permitido para uso em rede[N:Quantidade de computadores][G:a]',
  `GUID` VARCHAR(36) NULL DEFAULT NULL COMMENT 'Código único da empresa, permite baixar novas licenças automaticamente[N:Identificador da empresa][G:o]',
  `Opcoes` TEXT NULL DEFAULT NULL COMMENT 'Opções gerais do sistema como opções de impressão[N:Opções do sistema][G:a]',
  `UltimoBackup` DATETIME NULL DEFAULT NULL COMMENT 'Informa qual foi a data da última realização de backup do banco de dados do sistema[N:Data do último backup][G:a]',
  `VersaoDB` VARCHAR(45) NOT NULL COMMENT 'Informa qual a versão do banco de dados[N:Versão do banco de dados][G:a][S]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Sistema_Clientes_EmpresaID_idx` (`EmpresaID` ASC),
  INDEX `FK_Sistema_Clientes_ParceiroID_idx` (`ParceiroID` ASC),
  INDEX `FK_Sistema_Paises_PaisID_idx` (`PaisID` ASC),
  CONSTRAINT `FK_Sistema_Clientes_EmpresaID`
    FOREIGN KEY (`EmpresaID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Sistema_Clientes_ParceiroID`
    FOREIGN KEY (`ParceiroID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Sistema_Paises_PaisID`
    FOREIGN KEY (`PaisID`)
    REFERENCES `Paises` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Classe que informa detalhes da empresa, parceiro e opções ' /* comment truncated */ /*do sistema como a versão do banco de dados e a licença de uso[N:Sistema|Sistemas][G:o][L:AlterarConfiguracoes][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Informacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Informacoes` ;

CREATE TABLE IF NOT EXISTS `Informacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da informação nutricional[G:o]',
  `ProdutoID` INT NOT NULL COMMENT 'Produto a que essa tabela de informações nutricionais pertence[N:Produto][G:o][S]',
  `UnidadeID` INT NOT NULL COMMENT 'Unidade de medida da porção[N:Unidade][G:a]',
  `Porcao` DOUBLE NOT NULL COMMENT 'Quantidade da porção para base nos valores nutricionais[N:Porção][G:a]',
  `Dieta` DOUBLE NOT NULL DEFAULT 2000000 COMMENT 'Informa a quantidade de referência da dieta geralmente 2000kcal ou 8400kJ[N:Dieta][G:a]',
  `Ingredientes` TEXT NULL DEFAULT NULL COMMENT 'Informa todos os ingredientes que compõe o produto[N:Ingredientes][G:o]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Informacoes_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  UNIQUE INDEX `ProdutoID_UNIQUE` (`ProdutoID` ASC),
  INDEX `FK_Informacoes_Unidades_UnidadeID_idx` (`UnidadeID` ASC),
  CONSTRAINT `FK_Informacoes_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Informacoes_Unidades_UnidadeID`
    FOREIGN KEY (`UnidadeID`)
    REFERENCES `Unidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Permite cadastrar informações da tabela nutricional[N:Info' /* comment truncated */ /*rmação nutricional|Informações nutricionais][G:a][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Resumos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Resumos` ;

CREATE TABLE IF NOT EXISTS `Resumos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do resumo[G:o]',
  `MovimentacaoID` INT NOT NULL COMMENT 'Movimentação do caixa referente ao resumo[N:Movimentação][G:a][S]',
  `Tipo` ENUM('Dinheiro', 'Cartao', 'Cheque', 'Conta', 'Credito', 'Transferencia') NOT NULL COMMENT 'Tipo de pagamento do resumo[N:Tipo][G:o][E:Dinheiro|Cartão|Cheque|Conta|Crédito|Transferência][S:S]',
  `CartaoID` INT NULL DEFAULT NULL COMMENT 'Cartão da forma de pagamento[N:Cartão][G:o]',
  `Valor` DECIMAL(19,4) NOT NULL COMMENT 'Valor que foi contado ao fechar o caixa[N:Valor][G:o]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Resumos_Movimentacoes_MovimentacaoID_idx` (`MovimentacaoID` ASC),
  INDEX `FK_Resumos_Cartoes_CartaoID_idx` (`CartaoID` ASC),
  UNIQUE INDEX `UK_Resumos_MovimentacaoID_Tipo_CartaoID` (`MovimentacaoID` ASC, `Tipo` ASC, `CartaoID` ASC),
  CONSTRAINT `FK_Resumos_Movimentacoes_MovimentacaoID`
    FOREIGN KEY (`MovimentacaoID`)
    REFERENCES `Movimentacoes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Resumos_Cartoes_CartaoID`
    FOREIGN KEY (`CartaoID`)
    REFERENCES `Cartoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Resumo de fechamento de caixa, informa o valor contado no fe' /* comment truncated */ /*chamento do caixa para cada forma de pagamento[N:Resumo|Resumos][G:o][L:ConferirCaixa][K:MZ\Session|MZ\Session\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Formacoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Formacoes` ;

CREATE TABLE IF NOT EXISTS `Formacoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da formação[G:o]',
  `ProdutoPedidoID` INT NOT NULL COMMENT 'Informa qual foi o produto vendido para essa formação[N:Item do pedido][G:o][S:S]',
  `Tipo` ENUM('Pacote', 'Composicao') NOT NULL DEFAULT 'Pacote' COMMENT 'Informa qual tipo de formação foi escolhida, Pacote: O produto ou propriedade faz parte de um pacote, Composição: O produto é uma composição e esse item foi retirado ou adicionado na venda[N:Tipo][G:o]',
  `PacoteID` INT NULL DEFAULT NULL COMMENT 'Informa qual pacote foi selecionado no momento da venda[N:Pacote][G:o][S]',
  `ComposicaoID` INT NULL DEFAULT NULL COMMENT 'Informa qual composição foi retirada ou adicionada no momento da venda[N:Composição][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Formacoes_ProdPed_ProdutoPedidoID_idx` (`ProdutoPedidoID` ASC),
  INDEX `FK_Formacoes_Pacotes_PacoteID_idx` (`PacoteID` ASC),
  UNIQUE INDEX `UK_Formacoes_ProdutoPedidoID_PacoteID` (`ProdutoPedidoID` ASC, `PacoteID` ASC),
  INDEX `FK_Formacoes_Composicoes_ComposicaoID_idx` (`ComposicaoID` ASC),
  CONSTRAINT `FK_Formacoes_ProdPed_ProdutoPedidoID`
    FOREIGN KEY (`ProdutoPedidoID`)
    REFERENCES `Produtos_Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Formacoes_Pacotes_PacoteID`
    FOREIGN KEY (`PacoteID`)
    REFERENCES `Pacotes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Formacoes_Composicoes_ComposicaoID`
    FOREIGN KEY (`ComposicaoID`)
    REFERENCES `Composicoes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa qual foi a formação que gerou esse produto, assim ' /* comment truncated */ /*como quais item foram retirados/adicionados da composição[N:Formação|Formações][G:a][L:Pagamento][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Listas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Listas` ;

CREATE TABLE IF NOT EXISTS `Listas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da lista de compras[G:o]',
  `Descricao` VARCHAR(100) NOT NULL COMMENT 'Nome da lista, pode ser uma data[N:Descrição][G:a][S]',
  `Estado` ENUM('Analise', 'Fechada', 'Comprada') NOT NULL DEFAULT 'Analise' COMMENT 'Estado da lista de compra. Análise: Ainda estão sendo adicionado produtos na lista, Fechada: Está pronto para compra, Comprada: Todos os itens foram comprados[N:Estado][G:o][E:Análise|Fechada|Comprada]',
  `EncarregadoID` INT NOT NULL COMMENT 'Informa o funcionário encarregado de fazer as compras[N:Encarregado][G:o][S:S]',
  `DataViagem` DATETIME NOT NULL COMMENT 'Data e hora para o encarregado ir fazer as compras[N:Data de viagem][G:a]',
  `DataCadastro` DATETIME NOT NULL COMMENT 'Data de cadastro da lista[N:Data de cadastro][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Listas_Funcionario_EncarregadoID_idx` (`EncarregadoID` ASC),
  CONSTRAINT `FK_Listas_Funcionario_EncarregadoID`
    FOREIGN KEY (`EncarregadoID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Lista de compras de produtos[N:Lista de compra|Listas de com' /* comment truncated */ /*pras][G:a][L:ListaCompras][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Modulos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Modulos` ;

CREATE TABLE IF NOT EXISTS `Modulos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do módulo[G:o]',
  `Nome` VARCHAR(50) NOT NULL COMMENT 'Nome do módulo, unico em todo o sistema[N:Nome][G:o][S]',
  `Descricao` VARCHAR(200) NOT NULL COMMENT 'Descrição do módulo, informa detalhes sobre a funcionalidade do módulo no sistema[N:Descrição][G:a]',
  `ImageIndex` INT NOT NULL COMMENT 'Índice da imagem que representa o módulo, tamanho 64x64[N:Imagem][G:a]',
  `Habilitado` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o módulo do sistema está habilitado[N:Habilitado][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC))
ENGINE = InnoDB
COMMENT = 'Módulos do sistema que podem ser desativados/ativados[N:Mó' /* comment truncated */ /*dulo|Módulos][G:o][L:AlterarConfiguracoes][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Compras`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Compras` ;

CREATE TABLE IF NOT EXISTS `Compras` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da compra',
  `Numero` VARCHAR(50) NULL DEFAULT NULL COMMENT 'Informa o número fiscal da compra[N:Número da compra][G:o]',
  `CompradorID` INT NOT NULL COMMENT 'Informa o funcionário que comprou os produtos da lista[N:Comprador][G:o][S:S]',
  `FornecedorID` INT NOT NULL COMMENT 'Fornecedor em que os produtos foram compras[N:Fornecedor][G:o][S:S]',
  `DocumentoURL` VARCHAR(150) NULL DEFAULT NULL COMMENT 'Informa o nome do documento no servidor do sistema[N:Documento][G:o]',
  `DataCompra` DATETIME NOT NULL COMMENT 'Informa da data de finalização da compra[N:Data da compra][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Compras_Fornecedores_FornecedorID_idx` (`FornecedorID` ASC),
  INDEX `FK_Compras_Funcionarios_CompradorID_idx` (`CompradorID` ASC),
  UNIQUE INDEX `Numero_UNIQUE` (`Numero` ASC),
  CONSTRAINT `FK_Compras_Fornecedores_FornecedorID`
    FOREIGN KEY (`FornecedorID`)
    REFERENCES `Fornecedores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Compras_Funcionarios_CompradorID`
    FOREIGN KEY (`CompradorID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Compras realizadas em uma lista num determinado fornecedor[N' /* comment truncated */ /*:Compra|Compras][G:a][L:ListaCompras][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Requisitos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Requisitos` ;

CREATE TABLE IF NOT EXISTS `Requisitos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do produto da lista[G:o]',
  `ListaID` INT NOT NULL COMMENT 'Lista de compra desse produto[N:Lista de compra][G:a][S:S]',
  `ProdutoID` INT NOT NULL COMMENT 'Produto que deve ser comprado[N:Produto][G:o][S][S:S]',
  `CompraID` INT NULL DEFAULT NULL COMMENT 'Informa em qual fornecedor foi realizado a compra desse produto[G:a][N:Compra][S:S]',
  `FornecedorID` INT NULL DEFAULT NULL COMMENT 'Fornecedor em que deve ser consultado ou realizado as compras dos produtos, pode ser alterado no momento da compra[N:Fornecedor][G:o][S:S]',
  `Quantidade` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Quantidade de produtos que deve ser comprado[N:Quantidade][G:a]',
  `Comprado` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Informa quantos produtos já foram comprados[N:Comprado][G:o]',
  `PrecoMaximo` DECIMAL(19,4) NOT NULL COMMENT 'Preço máximo que deve ser pago na compra desse produto[N:Preço máximo][G:o]',
  `Preco` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Preço em que o produto foi comprado da última vez ou o novo preço[N:Preço][G:o]',
  `Observacoes` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Detalhes na compra desse produto[N:Observações][G:a]',
  `DataRecolhimento` DATETIME NULL DEFAULT NULL COMMENT 'Informa o momento do recolhimento da mercadoria na pratileira[N:Data de recolhimento][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Requisitos_Listas_ListaID_idx` (`ListaID` ASC),
  INDEX `FK_Requisitos_Produtos_ProdutoID_idx` (`ProdutoID` ASC),
  INDEX `FK_Requisitos_Fornecedores_FornecedorID_idx` (`FornecedorID` ASC),
  INDEX `FK_Requisitos_Compras_CompraID_idx` (`CompraID` ASC),
  CONSTRAINT `FK_Requisitos_Listas_ListaID`
    FOREIGN KEY (`ListaID`)
    REFERENCES `Listas` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Requisitos_Produtos_ProdutoID`
    FOREIGN KEY (`ProdutoID`)
    REFERENCES `Produtos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Requisitos_Fornecedores_FornecedorID`
    FOREIGN KEY (`FornecedorID`)
    REFERENCES `Fornecedores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Requisitos_Compras_CompraID`
    FOREIGN KEY (`CompraID`)
    REFERENCES `Compras` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa os produtos da lista de compras[N:Produtos da lista|' /* comment truncated */ /*Produtos das listas][G:o][L:ListaCompras][K:MZ\Stock|MZ\Stock\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Enderecos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Enderecos` ;

CREATE TABLE IF NOT EXISTS `Enderecos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do endereço[G:o]',
  `CidadeID` INT NOT NULL COMMENT 'Cidade a qual o endereço pertence[N:Cidade][G:a][S:S]',
  `BairroID` INT NOT NULL COMMENT 'Bairro a qual o endereço está localizado[N:Bairro][G:o][S:S]',
  `Logradouro` VARCHAR(200) NOT NULL COMMENT 'Nome da rua ou avenida[N:Logradouro][G:o][S]',
  `CEP` VARCHAR(8) NOT NULL COMMENT 'Código dos correios para identificar a rua ou avenida[N:CEP][G:o][M:99999-999]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `CEP_UNIQUE` (`CEP` ASC),
  INDEX `FK_Enderecos_Cidades_CidadeID_idx` (`CidadeID` ASC),
  INDEX `FK_Enderecos_Bairros_BairroID_idx` (`BairroID` ASC),
  UNIQUE INDEX `BairroID_Logradouro_UNIQUE` (`BairroID` ASC, `Logradouro` ASC),
  CONSTRAINT `FK_Enderecos_Cidades_CidadeID`
    FOREIGN KEY (`CidadeID`)
    REFERENCES `Cidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Enderecos_Bairros_BairroID`
    FOREIGN KEY (`BairroID`)
    REFERENCES `Bairros` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Endereços de ruas e avenidas com informação de CEP[N:Ende' /* comment truncated */ /*reço|Endereços][G:o][L:CadastroBairros][K:MZ\Location|MZ\Location\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Horarios`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Horarios` ;

CREATE TABLE IF NOT EXISTS `Horarios` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do horário[G:o]',
  `Inicio` INT NOT NULL COMMENT 'Início do horário de funcionamento em minutos contando a partir de domingo até sábado[N:Início][G:o]',
  `Fim` INT NOT NULL COMMENT 'Duração em minutos em que o restaurante ficará aberto contando a partir de domingo[N:Fim][G:o]',
  `TempoEntrega` INT NULL DEFAULT NULL COMMENT 'Tempo médio de entrega em minutos dos pedidos para entrega no dia informado[N:Tempo de entrega][G:o]',
  PRIMARY KEY (`ID`))
ENGINE = InnoDB
COMMENT = 'Informa o horário de funcionamento do estabelecimento[N:Hor' /* comment truncated */ /*ário|Horários][G:o][L:AlterarHorario][K:MZ\Company|MZ\Company\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Valores_Nutricionais`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Valores_Nutricionais` ;

CREATE TABLE IF NOT EXISTS `Valores_Nutricionais` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do valor nutricional[G:o]',
  `InformacaoID` INT NOT NULL COMMENT 'Informe a que tabela nutricional este valor pertence[N:Informação][G:a][S:S]',
  `UnidadeID` INT NOT NULL COMMENT 'Unidade de medida do valor nutricional, geralmente grama, exceto para valor energético[N:Unidade][G:a]',
  `Nome` VARCHAR(100) NOT NULL COMMENT 'Nome do valor nutricional[N:Nome][G:o][S]',
  `Quantidade` DOUBLE NOT NULL COMMENT 'Quantidade do valor nutricional com base na porção[N:Quantidade][G:a]',
  `ValorDiario` DOUBLE NULL DEFAULT NULL COMMENT 'Valor diário em %[N:Valor diário][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `UK_Informacao_Nome` (`InformacaoID` ASC, `Nome` ASC),
  INDEX `FK_Valores_Nutricionais_Unidades_UnidadeID_idx` (`UnidadeID` ASC),
  CONSTRAINT `FK_Valores_Nutricionais_Informacoes_InformacaoID`
    FOREIGN KEY (`InformacaoID`)
    REFERENCES `Informacoes` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Valores_Nutricionais_Unidades_UnidadeID`
    FOREIGN KEY (`UnidadeID`)
    REFERENCES `Unidades` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa todos os valores nutricionais da tabela nutricional[' /* comment truncated */ /*N:Valor nutricional|Valores nutricionais][G:o][L:CadastroProdutos][K:MZ\Product|MZ\Product\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Transferencias`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Transferencias` ;

CREATE TABLE IF NOT EXISTS `Transferencias` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da transferência[G:o]',
  `PedidoID` INT NOT NULL COMMENT 'Identificador do pedido de origem[N:Pedido de origem][G:o][S][S:S]',
  `DestinoPedidoID` INT NOT NULL COMMENT 'Identificador do pedido de destino[N:Pedido de destino][G:o][S:S]',
  `Tipo` ENUM('Pedido', 'Produto') NOT NULL COMMENT 'Tipo de transferência, se de mesa/comanda ou de produto[N:Tipo][G:o]',
  `Modulo` ENUM('Mesa', 'Comanda') NOT NULL COMMENT 'Módulo de venda, se mesa ou comanda[N:Módulo][G:o][S:S]',
  `MesaID` INT NULL DEFAULT NULL COMMENT 'Identificador da mesa de origem[N:Mesa de origem][G:a][S:S]',
  `DestinoMesaID` INT NULL DEFAULT NULL COMMENT 'Mesa de destino da transferência[N:Mesa de destino][G:a][S:S]',
  `ComandaID` INT NULL DEFAULT NULL COMMENT 'Comanda de origem da transferência[N:Comanda de origem][G:a][S:S]',
  `DestinoComandaID` INT NULL DEFAULT NULL COMMENT 'Comanda de destino[N:Comanda de destino][G:a][S:S]',
  `ProdutoPedidoID` INT NULL DEFAULT NULL COMMENT 'Item que foi transferido[N:Item transferido][G:o][S:S]',
  `FuncionarioID` INT NOT NULL COMMENT 'Funcionário que transferiu esse pedido/produto[N:Funcionário][G:o][S:S]',
  `DataHora` DATETIME NOT NULL COMMENT 'Data e hora da transferência[N:Data e hora][G:a][D]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Transf_Pedidos_PedidoID_idx` (`PedidoID` ASC),
  INDEX `FK_Transf_Pedidos_DestinoPedidoID_idx` (`DestinoPedidoID` ASC),
  INDEX `FK_Transf_Mesas_MesaID_idx` (`MesaID` ASC),
  INDEX `FK_Transf_Mesas_DestinoMesaID_idx` (`DestinoMesaID` ASC),
  INDEX `FK_Transf_Funcionarios_FuncionarioID_idx` (`FuncionarioID` ASC),
  INDEX `FK_Transf_Comandas_ComandaID_idx` (`ComandaID` ASC),
  INDEX `FK_Transf_Comandas_DestinoComandaID_idx` (`DestinoComandaID` ASC),
  INDEX `FK_Transf_ProdPed_ProdutoPedidoID_idx` (`ProdutoPedidoID` ASC),
  CONSTRAINT `FK_Transf_Pedidos_PedidoID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Pedidos_DestinoPedidoID`
    FOREIGN KEY (`DestinoPedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Mesas_MesaID`
    FOREIGN KEY (`MesaID`)
    REFERENCES `Mesas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Mesas_DestinoMesaID`
    FOREIGN KEY (`DestinoMesaID`)
    REFERENCES `Mesas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Funcionarios_FuncionarioID`
    FOREIGN KEY (`FuncionarioID`)
    REFERENCES `Funcionarios` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Comandas_ComandaID`
    FOREIGN KEY (`ComandaID`)
    REFERENCES `Comandas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_Comandas_DestinoComandaID`
    FOREIGN KEY (`DestinoComandaID`)
    REFERENCES `Comandas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Transf_ProdPed_ProdutoPedidoID`
    FOREIGN KEY (`ProdutoPedidoID`)
    REFERENCES `Produtos_Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa a transferência de uma mesa / comanda para outra, o' /* comment truncated */ /*u de um produto para outra mesa / comanda[N:Transferência|Transferências][G:a][L:TransferirProdutos][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Patrimonios`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Patrimonios` ;

CREATE TABLE IF NOT EXISTS `Patrimonios` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do bem[G:o]',
  `EmpresaID` INT NOT NULL COMMENT 'Empresa a que esse bem pertence[N:Empresa][G:a][S:S]',
  `FornecedorID` INT NULL DEFAULT NULL COMMENT 'Fornecedor do bem[N:Fornecedor][G:o][S:S]',
  `Numero` VARCHAR(45) NOT NULL COMMENT 'Número que identifica o bem[N:Número][G:o]',
  `Descricao` VARCHAR(200) NOT NULL COMMENT 'Descrição ou nome do bem[N:Descrição][G:a][S]',
  `Quantidade` DOUBLE NOT NULL COMMENT 'Quantidade do bem com as mesmas características[N:Quantidade][G:a]',
  `Altura` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Altura do bem em metros[N:Altura][G:a]',
  `Largura` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Largura do bem em metros[N:Largura][G:a]',
  `Comprimento` DOUBLE NOT NULL DEFAULT 0 COMMENT 'Comprimento do bem em metros[N:Comprimento][G:o]',
  `Estado` ENUM('Novo', 'Conservado', 'Ruim') NOT NULL DEFAULT 'Novo' COMMENT 'Estado de conservação do bem[N:Estado][G:o]',
  `Custo` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Valor de custo do bem[N:Custo][G:o]',
  `Valor` DECIMAL(19,4) NOT NULL DEFAULT 0 COMMENT 'Valor que o bem vale atualmente[N:Valor][G:o]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se o bem está ativo e em uso[N:Ativo][G:o]',
  `ImagemAnexada` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Caminho relativo da foto do bem[N:Foto do bem][G:a][I:512x512|patrimonio|patrimonio.png]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização das informações do bem[N:Data de atualização][G:a][D]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Numero_Estado_UNIQUE` (`Numero` ASC, `Estado` ASC),
  INDEX `FK_Patrimonios_Fornecedores_FornecedorID_idx` (`FornecedorID` ASC),
  INDEX `FK_Patrimonios_Clientes_EmpresaID_idx` (`EmpresaID` ASC),
  CONSTRAINT `FK_Patrimonios_Fornecedores_FornecedorID`
    FOREIGN KEY (`FornecedorID`)
    REFERENCES `Fornecedores` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Patrimonios_Clientes_EmpresaID`
    FOREIGN KEY (`EmpresaID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Informa detalhadamente um bem da empresa[N:Patrimônio|Patri' /* comment truncated */ /*mônios][G:o][L:CadastroPatrimonio][K:MZ\Environment|MZ\Environment\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Paginas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Paginas` ;

CREATE TABLE IF NOT EXISTS `Paginas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da página[G:o]',
  `Nome` VARCHAR(45) NOT NULL COMMENT 'Nome da página, único no sistema com o código da linguagem[N:Nome][G:o][S]',
  `LinguagemID` INT NOT NULL DEFAULT 0 COMMENT 'Código da linguagem para exibição no idioma correto, único com o nome[N:Linguagem][G:a]',
  `Conteudo` TEXT NULL DEFAULT NULL COMMENT 'Conteúdo da página, geralmente texto formatado em HTML[N:Conteúdo][G:o]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_LinguagemID_UNIQUE` (`Nome` ASC, `LinguagemID` ASC))
ENGINE = InnoDB
COMMENT = 'Página WEB que contém informações de contato, termos e o' /* comment truncated */ /*utras informações da empresa[N:Página|Páginas][G:a][L:AlterarPaginas][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Juncoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Juncoes` ;

CREATE TABLE IF NOT EXISTS `Juncoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da junção[G:o]',
  `MesaID` INT NOT NULL COMMENT 'Mesa que está junta ao pedido[N:Mesa][G:a][S]',
  `PedidoID` INT NOT NULL COMMENT 'Pedido a qual a mesa está junta, o pedido deve ser de uma mesa[N:Pedido][G:o][S:S]',
  `Estado` ENUM('Associado', 'Liberado', 'Cancelado') NOT NULL COMMENT 'Estado a junção da mesa. Associado: a mesa está junta ao pedido, Liberado: A mesa está livre, Cancelado: A mesa está liberada [N:Estado][G:o]',
  `DataMovimento` DATETIME NOT NULL COMMENT 'Data e hora da junção das mesas[N:Data do movimento][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Juncoes_Mesas_MesaID_idx` (`MesaID` ASC),
  INDEX `FK_Juncoes_Pedidos_PedidoID_idx` (`PedidoID` ASC),
  INDEX `MesaEstado_INDEX` (`MesaID` ASC, `Estado` ASC),
  CONSTRAINT `FK_Juncoes_Mesas_MesaID`
    FOREIGN KEY (`MesaID`)
    REFERENCES `Mesas` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Juncoes_Pedidos_PedidoID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Junções de mesas, informa quais mesas estão juntas ao ped' /* comment truncated */ /*ido[N:Junção|Junções][G:a][L:MudarDeMesa][K:MZ\Sale|MZ\Sale\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Regimes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Regimes` ;

CREATE TABLE IF NOT EXISTS `Regimes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do regime tributário[G:o]',
  `Codigo` INT NOT NULL COMMENT 'Código do regime tributário[G:o][N:Código]',
  `Descricao` VARCHAR(200) NOT NULL COMMENT 'Descrição do regime tributário[G:a][N:Descrição]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Codigo_UNIQUE` (`Codigo` ASC))
ENGINE = InnoDB
COMMENT = 'Regimes tributários[N:Regime|Regimes][G:o][L:AlterarConfigu' /* comment truncated */ /*racoes][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Emitentes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Emitentes` ;

CREATE TABLE IF NOT EXISTS `Emitentes` (
  `ID` ENUM('1') NOT NULL DEFAULT '1' COMMENT 'Identificador do emitente, sempre 1[G:o]',
  `ContadorID` INT NULL DEFAULT NULL COMMENT 'Contador responsável pela contabilidade da empresa[N:Contador][G:o][S:S]',
  `RegimeID` INT NOT NULL COMMENT 'Regime tributário da empresa[N:Regime tributário][G:o]',
  `Ambiente` ENUM('Homologacao', 'Producao') NOT NULL COMMENT 'Ambiente de emissão das notas[N:Ambiente][G:o][E:Homologação|Produção]',
  `CSC` VARCHAR(100) NOT NULL COMMENT 'Código de segurança do contribuinte[G:o]',
  `Token` VARCHAR(10) NOT NULL COMMENT 'Token do código de segurança do contribuinte[N:Token][G:o]',
  `IBPT` VARCHAR(100) NULL DEFAULT NULL COMMENT 'Token da API do IBPT[N:Token IBPT][G:o]',
  `ChavePrivada` VARCHAR(100) NOT NULL COMMENT 'Nome do arquivo da chave privada[G:a][N:Chave privada]',
  `ChavePublica` VARCHAR(100) NOT NULL COMMENT 'Nome do arquivo da chave pública[G:a][N:Chave pública]',
  `DataExpiracao` DATETIME NOT NULL COMMENT 'Data de expiração do certificado[N:Data de expiração][G:a]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Emitentes_Clientes_ContadorID_idx` (`ContadorID` ASC),
  INDEX `FK_Emitentes_Regimes_RegimeID_idx` (`RegimeID` ASC),
  CONSTRAINT `FK_Emitentes_Clientes_ContadorID`
    FOREIGN KEY (`ContadorID`)
    REFERENCES `Clientes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `FK_Emitentes_Regimes_RegimeID`
    FOREIGN KEY (`RegimeID`)
    REFERENCES `Regimes` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Dados do emitente das notas fiscais[N:Emitente|Emitentes][G:' /* comment truncated */ /*o][L:AlterarConfiguracoes][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Notas`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Notas` ;

CREATE TABLE IF NOT EXISTS `Notas` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da nota[G:o]',
  `Tipo` ENUM('Nota', 'Inutilizacao') NOT NULL COMMENT 'Tipo de registro se nota ou inutilização[G:o][E:Nota|Inutilização][N:Tipo]',
  `Ambiente` ENUM('Homologacao', 'Producao') NOT NULL COMMENT 'Ambiente em que a nota foi gerada[G:o][N:Ambiente][E:Homologação|Produção]',
  `Acao` ENUM('Autorizar', 'Cancelar', 'Inutilizar') NOT NULL COMMENT 'Ação que deve ser tomada sobre a nota fiscal[N:Ação][E:Autorizar|Cancelar|Inutilizar]',
  `Estado` ENUM('Aberto', 'Assinado', 'Pendente', 'Processamento', 'Denegado', 'Rejeitado', 'Cancelado', 'Inutilizado', 'Autorizado') NOT NULL COMMENT 'Estado da nota[G:o][N:Estado][E:Aberto|Assinado|Pendente|Em processamento|Denegado|Rejeitado|Cancelado|Inutilizado|Autorizado]',
  `Serie` INT NOT NULL COMMENT 'Série da nota[G:a][N:Série]',
  `NumeroInicial` INT NOT NULL COMMENT 'Número inicial da nota[G:o][N:Número]',
  `NumeroFinal` INT NOT NULL COMMENT 'Número final da nota, igual ao número inicial quando for a nota de um pedido[G:o][N:Número inicial]',
  `Sequencia` INT NOT NULL COMMENT 'Permite iniciar o número da nota quando alcançar 999.999.999, deve ser incrementado sempre que alcançar[G:o][N:Sequencia]',
  `Chave` VARCHAR(50) NULL DEFAULT NULL COMMENT 'Chave da nota fiscal[G:a][N:Chave]',
  `Recibo` VARCHAR(50) NULL DEFAULT NULL COMMENT 'Recibo de envio para consulta posterior[G:o][N:Recibo]',
  `Protocolo` VARCHAR(80) NULL DEFAULT NULL COMMENT 'Protocolo de autorização da nota fiscal[G:o][N:Protocolo]',
  `PedidoID` INT NULL DEFAULT NULL COMMENT 'Pedido da nota[N:Pedido][S:S]',
  `Motivo` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Motivo do cancelamento, contingência ou inutilização[G:o][N:Motivo]',
  `Contingencia` ENUM('Y', 'N') NOT NULL COMMENT 'Informa se a nota está em contingência[G:a][N:Contingência]',
  `ConsultaURL` VARCHAR(255) NULL DEFAULT NULL COMMENT 'URL de consulta da nota fiscal[G:o][N:URL de consulta]',
  `QRCode` TEXT NULL DEFAULT NULL COMMENT 'Dados do QRCode da nota[G:o][N:QRCode]',
  `Tributos` DECIMAL(19,4) NULL DEFAULT NULL COMMENT 'Tributos totais da nota[G:o][N:Tributos]',
  `Detalhes` VARCHAR(255) NULL DEFAULT NULL COMMENT 'Informações de interesse do contribuinte[G:a][N:Informações de interesse do contribuinte]',
  `Corrigido` ENUM('Y', 'N') NOT NULL DEFAULT 'Y' COMMENT 'Informa se os erros já foram corrigidos para retomada do processamento[G:o][N:Corrigido]',
  `Concluido` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa se todos os processamentos da nota já foram realizados[G:o][N:Concluído]',
  `DataAutorizacao` DATETIME NULL DEFAULT NULL COMMENT 'Data de autorização da nota fiscal[G:a][N:Data de autorização]',
  `DataEmissao` DATETIME NOT NULL COMMENT 'Data de emissão da nota[G:a][N:Data de emissão]',
  `DataLancamento` DATETIME NOT NULL COMMENT 'Data de lançamento da nota no sistema[G:a][N:Data de lançamento]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Notas_Pedidos_PedidoID_idx` (`PedidoID` ASC),
  INDEX `IDX_Chave` (`Chave` ASC),
  CONSTRAINT `FK_Notas_Pedidos_PedidoID`
    FOREIGN KEY (`PedidoID`)
    REFERENCES `Pedidos` (`ID`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Notas fiscais e inutilizações[N:Nota|Notas][G:a][L:Relator' /* comment truncated */ /*ioPedidos][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Eventos`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Eventos` ;

CREATE TABLE IF NOT EXISTS `Eventos` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador do evento[G:o]',
  `NotaID` INT NOT NULL COMMENT 'Nota a qual o evento foi criado[G:a][N:Nota][S:S]',
  `Estado` ENUM('Aberto', 'Assinado', 'Validado', 'Pendente', 'Processamento', 'Denegado', 'Cancelado', 'Rejeitado', 'Contingencia', 'Inutilizado', 'Autorizado') NOT NULL COMMENT 'Estado do evento[G:o][N:Estado][E:Aberto|Assinado|Pendente|Em processamento|Denegado|Cancelado|Rejeitado|Contingência|Inutilizado|Autorizado]',
  `Mensagem` TEXT NOT NULL COMMENT 'Mensagem do evento, descreve que aconteceu[G:a][N:Mensagem]',
  `Codigo` VARCHAR(20) NOT NULL COMMENT 'Código de status do evento, geralmente código de erro de uma exceção[G:o][N:Código]',
  `DataCriacao` DATETIME NOT NULL COMMENT 'Data de criação do evento[G:a][N:Data de criação]',
  PRIMARY KEY (`ID`),
  INDEX `FK_Eventos_Notas_NotaID_idx` (`NotaID` ASC),
  CONSTRAINT `FK_Eventos_Notas_NotaID`
    FOREIGN KEY (`NotaID`)
    REFERENCES `Notas` (`ID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Eventos de envio das notas[N:Evento|Eventos][G:o][L:Relatori' /* comment truncated */ /*oAuditoria][K:MZ\Invoice|MZ\Invoice\][H:\MZ\Database\Helper]*/;


-- -----------------------------------------------------
-- Table `Integracoes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `Integracoes` ;

CREATE TABLE IF NOT EXISTS `Integracoes` (
  `ID` INT NOT NULL AUTO_INCREMENT COMMENT 'Identificador da integração[N:ID][G:o]',
  `Nome` VARCHAR(45) NOT NULL COMMENT 'Nome do módulo de integração[G:o][N:Nome]',
  `AcessoURL` VARCHAR(100) NOT NULL COMMENT 'Nome da URL de acesso[N:URL][G:a]',
  `Descricao` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Descrição do módulo integrador[G:a][N:Descrição]',
  `IconeURL` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Nome do ícone do módulo integrador[G:o][N:Ícone][I:128x128|integracao|integracao.png]',
  `Ativo` ENUM('Y', 'N') NOT NULL DEFAULT 'N' COMMENT 'Informa de o módulo de integração está habilitado[G:o][N:Habilitado]',
  `Token` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Token de acesso à API de sincronização[N:Token][G:o]',
  `Secret` VARCHAR(200) NULL DEFAULT NULL COMMENT 'Chave secreta para acesso à API[G:a][N:Chave secreta]',
  `DataAtualizacao` DATETIME NOT NULL COMMENT 'Data de atualização dos dados do módulo de integração[G:a][N:Data de atualização]',
  PRIMARY KEY (`ID`),
  UNIQUE INDEX `Nome_UNIQUE` (`Nome` ASC),
  UNIQUE INDEX `AcessoURL_UNIQUE` (`AcessoURL` ASC))
ENGINE = InnoDB
COMMENT = 'Informa quais integrações estão disponíveis[N:Inte' /* comment truncated */ /*gração|Integrações][G:a][L:AlterarConfiguracoes][K:MZ\System|MZ\System\][H:\MZ\Database\Helper]*/;


DELIMITER $$

DROP TRIGGER IF EXISTS `Sessoes_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Sessoes_BEFORE_INSERT` BEFORE INSERT ON `Sessoes` FOR EACH ROW
BEGIN
	DECLARE _existe INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT 1 INTO _existe FROM Sessoes WHERE Aberta = 'Y';
	IF _existe = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma sessão aberta";
    ELSEIF NEW.Aberta = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A sessão não pode iniciar fechada";
    ELSEIF NOT ISNULL(NEW.DataTermino) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de término da sessão não deve ser informada agora";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Sessoes_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Sessoes_BEFORE_UPDATE` BEFORE UPDATE ON `Sessoes` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _abertos INT;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT COUNT(ID) INTO _abertos FROM Movimentacoes WHERE SessaoID = OLD.ID AND Aberta = 'Y';
	IF NEW.Aberta = 'N' AND _abertos = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Ainda há um caixa aberto";
	ELSEIF NEW.Aberta = 'N' AND _abertos > 1 THEN
		SET _error_msg = CONCAT("Ainda há ", _abertos, " caixas abertos");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
    ELSEIF NEW.Aberta = 'Y' AND OLD.Aberta = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A sessão não pode ser reaberta";
    ELSEIF OLD.DataInicio <> NEW.DataInicio THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de início da sessão não pode ser alterada";
    ELSEIF OLD.Aberta = 'N' AND OLD.DataTermino <> NEW.DataTermino THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de término da sessão não pode ser alterada";
    ELSEIF NEW.Aberta = 'Y' AND NOT ISNULL(NEW.DataTermino) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de término da sessão não deve ser informada agora";
    ELSEIF NEW.Aberta = 'N' AND ISNULL(NEW.DataTermino) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de término da sessão deve ser informada";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Caixas_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Caixas_BEFORE_UPDATE` BEFORE UPDATE ON `Caixas` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _mov_count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	IF NEW.Ativo = 'N' AND OLD.Ativo = 'Y' THEN
		SELECT COUNT(ID) INTO _mov_count FROM Movimentacoes WHERE CaixaID = OLD.ID AND Aberta = 'Y';
		IF _mov_count > 0 THEN
			SET _error_msg = CONCAT("O caixa '", OLD.Descricao, "' está aberto");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
		END IF;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Formas_Pagto_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Formas_Pagto_BEFORE_UPDATE` BEFORE UPDATE ON `Formas_Pagto` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
    
	SELECT COUNT(ID) INTO _count FROM Pagamentos 
		WHERE FormaPagtoID = OLD.ID;
	IF _count > 0 AND OLD.Tipo <> NEW.Tipo THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A forma de pagamento já foi utilizada e não pode mais ser alterada";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Funcionarios_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Funcionarios_BEFORE_INSERT` BEFORE INSERT ON `Funcionarios` FOR EACH ROW
BEGIN
IF @DISABLE_TRIGGERS IS NULL THEN
	IF NEW.Ativo = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O funcionário não pode ser cadastrado como inativo";
	ELSEIF NOT ISNULL(NEW.DataSaida) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de saída do funcionário não pode ser informada agora";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Movimentacoes_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Movimentacoes_BEFORE_INSERT` BEFORE INSERT ON `Movimentacoes` FOR EACH ROW
BEGIN
    DECLARE _error_msg VARCHAR(255);
	DECLARE _existe INT DEFAULT 0;
    DECLARE _aberta, _ativo, _f_ativo VARCHAR(1);
    DECLARE _descricao, _login VARCHAR(50);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT 1 INTO _existe FROM Movimentacoes WHERE SessaoID = NEW.SessaoID AND CaixaID = NEW.CaixaID AND Aberta = 'Y' AND 
		FuncionarioAberturaID = NEW.FuncionarioAberturaID;
	SELECT Aberta INTO _aberta FROM Sessoes WHERE ID = NEW.SessaoID;
	SELECT Ativo, Descricao INTO _ativo, _descricao FROM Caixas WHERE ID = NEW.CaixaID;
	SELECT f.Ativo, cf.Login INTO _f_ativo, _login FROM Funcionarios f LEFT JOIN Clientes cf ON cf.ID = f.ClienteID WHERE f.ID = NEW.FuncionarioAberturaID;
	IF _existe = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe um caixa aberto para o funcionário informado";
	ELSEIF _aberta = 'N' THEN
		SET _error_msg = CONCAT("A sessão ", NEW.SessaoID, " já foi fechada");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF _ativo = 'N' THEN
		SET _error_msg = CONCAT("O caixa '", _descricao, "' não está ativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF _f_ativo = 'N' THEN
		SET _error_msg = CONCAT("O funcionário '", _login, "' não está ativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF NEW.Aberta = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O caixa não pode ser aberto com status de fechado";
	ELSEIF NOT ISNULL(NEW.FuncionarioFechamentoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O funcionário de fechamento do caixa não pode ser informado agora";
	ELSEIF NOT ISNULL(NEW.DataFechamento) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de fechamento do caixa não pode ser informada agora";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Movimentacoes_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Movimentacoes_BEFORE_UPDATE` BEFORE UPDATE ON `Movimentacoes` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _abertos INT;
	DECLARE _desativados INT;
	DECLARE _outros_abertos INT;
	DECLARE _outros_caixas INT;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT COUNT(ID) INTO _abertos FROM Pedidos WHERE MovimentacaoID = OLD.ID AND Estado <> 'Finalizado' AND Cancelado = 'N';
	SELECT COUNT(ID) INTO _desativados FROM Pagamentos WHERE MovimentacaoID = OLD.ID AND Ativo = 'N' AND Cancelado = 'N';
	SELECT COUNT(ID) INTO _outros_abertos FROM Pedidos WHERE SessaoID = OLD.SessaoID AND Estado <> 'Finalizado' AND Cancelado = 'N';
	SELECT COUNT(ID) INTO _outros_caixas FROM Movimentacoes WHERE ID <> OLD.ID AND Aberta = 'Y';
    
	IF NEW.Aberta = 'N' AND _outros_abertos = 1 AND _outros_caixas = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Ainda há um pedido não finalizado";
	ELSEIF NEW.Aberta = 'N' AND _outros_abertos > 1 AND _outros_caixas = 0 THEN
		SET _error_msg = CONCAT("Ainda há ", _outros_abertos, " pedidos não finalizados");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF NEW.Aberta = 'N' AND _abertos = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Ainda há um pedido não finalizado";
	ELSEIF NEW.Aberta = 'N' AND _abertos > 1 THEN
		SET _error_msg = CONCAT("Ainda há ", _abertos, " pedidos não finalizados");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF NEW.Aberta = 'N' AND _desativados = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Ainda há um pagamento não finalizado";
	ELSEIF NEW.Aberta = 'N' AND _desativados > 1 THEN
		SET _error_msg = CONCAT("Ainda há ", _desativados, " pagamentos não finalizados");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
    ELSEIF NEW.Aberta = 'Y' AND OLD.Aberta = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O caixa não pode ser reaberto";
    ELSEIF NEW.Aberta = 'N' AND ISNULL(NEW.FuncionarioFechamentoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O funcionário que está fechando o caixa deve ser informado";
    ELSEIF NEW.Aberta = 'Y' AND NOT ISNULL(NEW.FuncionarioFechamentoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O funcionário que fechará o caixa não pode ser informado agora";
    ELSEIF NEW.Aberta = 'N' AND ISNULL(NEW.DataFechamento) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de fechamento deve ser informada";
    ELSEIF NEW.Aberta = 'Y' AND NOT ISNULL(NEW.DataFechamento) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de fechamento não pode ser informada agora";
    ELSEIF NEW.CaixaID <> OLD.CaixaID THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O id do caixa não pode ser alterado";
    ELSEIF NEW.SessaoID <> OLD.SessaoID THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A sessão do caixa não pode ser alterada";
    ELSEIF NEW.FuncionarioAberturaID <> OLD.FuncionarioAberturaID THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O funcionário que abriu o caixa não pode ser alterado";
    ELSEIF NEW.DataAbertura <> OLD.DataAbertura THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de abertura do caixa não pode ser alterada";
    ELSEIF OLD.Aberta = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Este caixa já foi fechado e não pode mais ser alterado";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Pedidos_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pedidos_BEFORE_INSERT` BEFORE INSERT ON `Pedidos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _nome VARCHAR(75);
	DECLARE _aberta VARCHAR(1);
	DECLARE _existe, _caixa_id, _sessao_id INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	IF NOT ISNULL(NEW.MovimentacaoID) THEN
		SELECT mv.Aberta, mv.SessaoID, mv.CaixaID, c.Descricao INTO _aberta, _sessao_id, _caixa_id, _nome FROM Movimentacoes mv
			LEFT JOIN Caixas c ON c.ID = mv.CaixaID
			WHERE mv.ID = NEW.MovimentacaoID;
        IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", NEW.MovimentacaoID, " já foi fechado");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        ELSEIF _sessao_id <> NEW.SessaoID THEN
			SET _error_msg = CONCAT("A movimentação de id ", NEW.MovimentacaoID, " não faz parte da sessão ", NEW.SessaoID);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
	ELSE
		SELECT Aberta INTO _aberta FROM Sessoes WHERE ID = NEW.SessaoID;
		IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("A sessão ", NEW.SessaoID, " já foi fechada");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
		END IF;
	END IF;
    
    IF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível cadastrar um pedido como cancelado";
    ELSEIF NEW.Pessoas < 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade de pessoas não pode ser negativa";
    ELSEIF NEW.Pessoas = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade de pessoas não pode ser nula";
    ELSEIF NEW.Pessoas > 1 AND NEW.Tipo = 'Comanda' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Pedidos de comandas são individuais";
    ELSEIF NEW.Tipo = 'Mesa' AND ISNULL(NEW.MesaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da mesa não foi informado";
    ELSEIF NEW.Tipo = 'Avulso' AND ISNULL(NEW.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Caixa não informado para o pedido avulso";
    ELSEIF NEW.Tipo = 'Entrega' AND ISNULL(NEW.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Caixa não informado para o pedido de entrega";
    ELSEIF NEW.Estado NOT IN ('Ativo', 'Agendado') THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido não está ativo ou não está agendado";
    ELSEIF NEW.Estado = 'Agendado' AND ISNULL(NEW.DataAgendamento) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de agendamento não foi informada";
    ELSEIF NOT ISNULL(NEW.DataEntrega) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido não pode ser entregue ao mesmo instante que é criado";
    ELSEIF NOT ISNULL(NEW.DataConclusao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido não pode estar concluído ao ser criado";
    ELSEIF NEW.Tipo NOT IN ('Mesa', 'Comanda') AND NOT ISNULL(NEW.MesaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa não pode ser informada nesse tipo de pedido";
    ELSEIF NEW.Tipo = 'Comanda' AND ISNULL(NEW.ComandaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da comanda não foi informado";
    ELSEIF NEW.Tipo <> 'Comanda' AND NOT ISNULL(NEW.ComandaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A comanda não pode ser informada nesse tipo de pedido";
    ELSEIF NEW.Tipo = 'Entrega' AND ISNULL(NEW.ClienteID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cliente não foi informado";
    ELSEIF NEW.Tipo = 'Mesa' THEN
		SELECT 1, m.Nome INTO _existe, _nome FROM Pedidos p
			LEFT JOIN Mesas m ON m.ID = p.MesaID
			WHERE p.Tipo = 'Mesa' AND p.MesaID = NEW.MesaID AND p.Estado <> 'Finalizado' AND p.Cancelado = 'N';
        IF _existe = 1 THEN
            SET _error_msg = CONCAT("A mesa '", _nome, "' já está aberta");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
		SELECT 1, m.Nome INTO _existe, _nome FROM Juncoes j
			LEFT JOIN Pedidos p ON p.ID = j.PedidoID
			LEFT JOIN Mesas m ON m.ID = p.MesaID
			WHERE j.MesaID = NEW.MesaID AND j.Estado = 'Associado';
        IF _existe = 1 THEN
			SET _error_msg = CONCAT("A mesa informada já está junta com a mesa '", _nome, "'");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    ELSEIF NEW.Tipo = 'Comanda' THEN
		SELECT 1, c.Nome INTO _existe, _nome FROM Pedidos p
			LEFT JOIN Comandas c ON c.ID = p.ComandaID
			WHERE p.Tipo = 'Comanda' AND p.ComandaID = NEW.ComandaID AND p.Estado <> 'Finalizado' AND p.Cancelado = 'N';
        IF _existe = 1 THEN
            SET _error_msg = CONCAT("A comanda '", _nome, "' já está aberta");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    ELSEIF NEW.Tipo = 'Avulso' THEN
		SELECT 1 INTO _existe FROM Pedidos
			WHERE Tipo = 'Avulso' AND MovimentacaoID = NEW.MovimentacaoID AND FuncionarioID = NEW.FuncionarioID AND Estado <> 'Finalizado' AND Cancelado = 'N';
        IF _existe = 1 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma venda avulsa em andamento";
        END IF;
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Pedidos_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pedidos_BEFORE_UPDATE` BEFORE UPDATE ON `Pedidos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _nome VARCHAR(75);
	DECLARE _aberta VARCHAR(1);
	DECLARE _existe, _caixa_id, _sessao_id, _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	IF NOT ISNULL(NEW.MovimentacaoID) AND (NOT (NEW.MovimentacaoID <=> OLD.MovimentacaoID) OR NEW.Cancelado = 'Y') THEN
		SELECT mv.Aberta, mv.SessaoID, mv.CaixaID, c.Descricao INTO _aberta, _sessao_id, _caixa_id, _nome FROM Movimentacoes mv
			LEFT JOIN Caixas c ON c.ID = mv.CaixaID
			WHERE mv.ID = NEW.MovimentacaoID;
        IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", NEW.MovimentacaoID, " já foi fechado");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        ELSEIF _sessao_id <> NEW.SessaoID THEN
			SET _error_msg = CONCAT("A movimentação de id ", NEW.MovimentacaoID, " não faz parte da sessão ", NEW.SessaoID);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
	END IF;
    IF NOT ISNULL(OLD.MovimentacaoID) AND NOT (NEW.MovimentacaoID <=> OLD.MovimentacaoID) THEN
		SELECT mv.Aberta, mv.SessaoID, mv.CaixaID, c.Descricao INTO _aberta, _sessao_id, _caixa_id, _nome FROM Movimentacoes mv
			LEFT JOIN Caixas c ON c.ID = mv.CaixaID
			WHERE mv.ID = OLD.MovimentacaoID;
        IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", OLD.MovimentacaoID, " já foi fechado");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
	END IF;
	IF NEW.SessaoID <> OLD.SessaoID THEN
		SELECT Aberta INTO _aberta FROM Sessoes WHERE ID = NEW.SessaoID;
		IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("A sessão ", NEW.SessaoID, " já foi fechada");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
		END IF;
	END IF;
    
    IF OLD.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar um pedido cancelado";
    ELSEIF OLD.Estado = 'Finalizado' AND NEW.Estado <> 'Finalizado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido não pode ser reaberto";
    ELSEIF OLD.Estado = 'Finalizado' AND NEW.Cancelado = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido já foi fechado e não pode mais ser alterado";
    ELSEIF NEW.Pessoas < 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade de pessoas não pode ser negativa";
    ELSEIF NEW.Pessoas = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade de pessoas não pode ser nula";
    ELSEIF NEW.Pessoas > 1 AND NEW.Tipo = 'Comanda' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Pedidos de comandas são individuais";
    ELSEIF NEW.Tipo = 'Mesa' AND ISNULL(NEW.MesaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da mesa não foi informado";
    ELSEIF NEW.Tipo = 'Avulso' AND ISNULL(NEW.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Caixa não informado para o pedido avulso";
    ELSEIF NEW.Tipo = 'Entrega' AND ISNULL(NEW.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Caixa não informado para o pedido de entrega";
    ELSEIF NEW.Estado = 'Agendado' AND ISNULL(NEW.DataAgendamento) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de agendamento não foi informada";
    ELSEIF NEW.Estado = 'Entrega' AND ISNULL(NEW.DataEntrega) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de entrega não foi informada";
    ELSEIF NEW.Estado = 'Finalizado' AND ISNULL(NEW.DataConclusao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de conclusão não foi informada";
    ELSEIF NEW.Tipo NOT IN ('Mesa', 'Comanda') AND NOT ISNULL(NEW.MesaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa não pode ser informada nesse tipo de pedido";
    ELSEIF NEW.Tipo = 'Comanda' AND ISNULL(NEW.ComandaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da comanda não foi informado";
    ELSEIF NEW.Tipo <> 'Comanda' AND NOT ISNULL(NEW.ComandaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A comanda não pode ser informada nesse tipo de pedido";
    ELSEIF NEW.Tipo = 'Entrega' AND ISNULL(NEW.ClienteID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cliente não foi informado";
    ELSEIF NEW.Tipo = 'Mesa' AND NEW.MesaID <> OLD.MesaID THEN
		SELECT 1, m.Nome INTO _existe, _nome FROM Pedidos p
			LEFT JOIN Mesas m ON m.ID = p.MesaID
			WHERE p.Tipo = 'Mesa' AND p.MesaID = NEW.MesaID AND p.Estado <> 'Finalizado' AND p.Cancelado = 'N';
        IF _existe = 1 THEN
            SET _error_msg = CONCAT("A mesa '", _nome, "' já está aberta");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
		SELECT 1, m.Nome INTO _existe, _nome FROM Juncoes j
			LEFT JOIN Pedidos p ON p.ID = j.PedidoID
			LEFT JOIN Mesas m ON m.ID = p.MesaID
			WHERE j.MesaID = NEW.MesaID AND j.Estado = 'Associado';
        IF _existe = 1 THEN
			SET _error_msg = CONCAT("A mesa informada já está junta com a mesa '", _nome, "'");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    ELSEIF NEW.Tipo = 'Comanda' AND NEW.ComandaID <> OLD.ComandaID THEN
		SELECT 1 INTO _existe FROM Pedidos WHERE Tipo = 'Comanda' AND ComandaID = NEW.ComandaID AND Estado <> 'Finalizado' AND Cancelado = 'N';
        IF _existe = 1 THEN
			SELECT Nome INTO _nome FROM Comandas WHERE ID = NEW.ComandaID;
            SET _error_msg = CONCAT("A comanda '", _nome, "' já está aberta");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    ELSEIF NEW.Tipo = 'Avulso' AND NEW.Tipo <> OLD.Tipo THEN
		SELECT 1 INTO _existe FROM Pedidos WHERE Tipo = 'Avulso' AND MovimentacaoID = NEW.MovimentacaoID AND FuncionarioID = NEW.FuncionarioID AND Estado <> 'Finalizado' AND Cancelado = 'N';
        IF _existe = 1 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma venda avulsa em andamento";
        END IF;
	END IF;
    IF NEW.Estado = 'Finalizado' AND NEW.Estado <> OLD.Estado AND NEW.Cancelado = 'N' THEN
		SELECT COUNT(ID) INTO _count FROM Produtos_Pedidos WHERE PedidoID = OLD.ID AND Cancelado = 'N';
        IF _count = 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Nenhum produto ou serviço foi adicionado ao pedido";
        END IF;
		SELECT COUNT(ID) INTO _count FROM Pagamentos WHERE PedidoID = OLD.ID AND Cancelado = 'N' AND Ativo = 'N';
        IF _count = 1 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Ainda há um pagamento não finalizado";
        ELSEIF _count > 1 THEN
			SET _error_msg = CONCAT("Ainda há ", _count, " pagamentos não finalizados");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
        IF OLD.Tipo = 'Mesa' THEN
			UPDATE Juncoes SET Estado = 'Liberado' WHERE PedidoID = OLD.ID AND Estado = 'Associado';
        END IF;
	ELSEIF NEW.Cancelado = 'Y' THEN
		UPDATE Produtos_Pedidos SET Motivo = NEW.Motivo, Cancelado = 'Y' WHERE PedidoID = OLD.ID AND Cancelado = 'N';
		UPDATE Pagamentos SET Cancelado = 'Y' WHERE PedidoID = OLD.ID AND Cancelado = 'N';
        IF OLD.Tipo = 'Mesa' THEN
			UPDATE Juncoes SET Estado = 'Cancelado' WHERE PedidoID = OLD.ID AND Estado <> 'Cancelado';
        END IF;
        UPDATE Notas SET Acao = IF(Estado = 'Aberto', 'Inutilizar', 'Cancelar'), Motivo = NEW.Motivo, Concluido = 'N', Corrigido = 'Y' WHERE PedidoID = OLD.ID AND Acao = 'Autorizar';
	ELSEIF OLD.Tipo <> NEW.Tipo AND OLD.Tipo = 'Mesa' THEN
		UPDATE Juncoes SET Estado = 'Liberado' WHERE PedidoID = OLD.ID AND Estado = 'Associado';
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Produtos_Pedidos_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Produtos_Pedidos_BEFORE_INSERT` BEFORE INSERT ON `Produtos_Pedidos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _descricao, _estado VARCHAR(75);
	DECLARE _divisivel, _cancelado, _ativo VARCHAR(1);
	DECLARE _login VARCHAR(50);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Descricao, Divisivel INTO _descricao, _divisivel FROM Produtos WHERE ID = NEW.ProdutoID;
	SELECT Cancelado, Estado INTO _cancelado, _estado FROM Pedidos WHERE ID = NEW.PedidoID;
    SELECT f.Ativo, cf.Login INTO _ativo, _login FROM Funcionarios f LEFT JOIN Clientes cf ON cf.ID = f.ClienteID WHERE f.ID = NEW.FuncionarioID;
    
    IF NEW.Quantidade < 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade não pode ser negativa";
    ELSEIF NEW.Quantidade = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade não pode ser nula";
    ELSEIF ISNULL(NEW.ProdutoID) AND ISNULL(NEW.ServicoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Um produto ou serviço deve ser informado";
    ELSEIF NOT ISNULL(NEW.ProdutoID) AND NOT ISNULL(NEW.ServicoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Apenas um produto ou serviço deve ser informado por vez";
    ELSEIF NOT ISNULL(NEW.ServicoID) AND NOT ISNULL(NEW.ProdutoPedidoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Um serviço não pode fazer parte de outro serviço ou produto";
    ELSEIF NEW.Preco < 0 AND NOT ISNULL(NEW.ProdutoID) THEN
		SET _error_msg = CONCAT("O valor do produto '", _descricao, "' não pode ser negativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
    ELSEIF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um produto ou serviço como cancelado";
    ELSEIF _cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um produto ou serviço em um pedido cancelado";
    ELSEIF _estado = 'Finalizado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um produto ou serviço em um pedido finalizado";
	ELSEIF _ativo = 'N' THEN
		SET _error_msg = CONCAT("O funcionário '", _login, "' não está ativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
    ELSEIF NEW.Estado <> 'Adicionado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O produto ou serviço deve ser inserido com estado de 'Adicionado'";
	ELSEIF NEW.Visualizado = 'Y' AND ISNULL(NEW.DataVisualizacao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um produto ou serviço visualizado sem a data e a hora";
	ELSEIF NEW.Visualizado = 'N' AND NOT ISNULL(NEW.DataVisualizacao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um produto não visualizado com a data e a hora";
	ELSEIF NOT ISNULL(NEW.ProdutoID) AND _divisivel = 'N' AND MOD(NEW.Quantidade, 1) > 0 THEN
		SET _error_msg = CONCAT("O produto '", _descricao, "' não é divisível");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Produtos_Pedidos_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Produtos_Pedidos_BEFORE_UPDATE` BEFORE UPDATE ON `Produtos_Pedidos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _descricao, _estado, _nome VARCHAR(75);
	DECLARE _divisivel, _cancelado, _ativo, _aberta VARCHAR(1);
	DECLARE _login VARCHAR(50);
    DECLARE _movimentacao_id INT;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Descricao, Divisivel INTO _descricao, _divisivel FROM Produtos WHERE ID = NEW.ProdutoID;
	SELECT MovimentacaoID, Cancelado, Estado INTO _movimentacao_id, _cancelado, _estado FROM Pedidos WHERE ID = NEW.PedidoID;
    SELECT f.Ativo, cf.Login INTO _ativo, _login FROM Funcionarios f LEFT JOIN Clientes cf ON cf.ID = f.ClienteID WHERE f.ID = NEW.FuncionarioID;
    
    IF NOT ISNULL(_movimentacao_id) THEN
		SELECT mv.Aberta, c.Descricao INTO _aberta, _nome FROM Movimentacoes mv
			LEFT JOIN Caixas c ON c.ID = mv.CaixaID
			WHERE mv.ID = _movimentacao_id;
        IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", _movimentacao_id, " já foi fechado");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
	END IF;
    
    IF OLD.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar um produto ou serviço cancelado";
    ELSEIF _cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar um produto ou serviço de um pedido cancelado";
    ELSEIF _estado = 'Finalizado' AND NEW.Cancelado <> 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar um produto ou serviço de um pedido finalizado";
    ELSEIF ISNULL(OLD.ProdutoID) <> ISNULL(NEW.ProdutoID) OR ISNULL(OLD.ServicoID) <> ISNULL(NEW.ServicoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar de produto para serviço ou vice versa";
    ELSEIF NOT ISNULL(NEW.ServicoID) AND NOT ISNULL(NEW.ProdutoPedidoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Um serviço não pode fazer parte de outro serviço ou produto";
    ELSEIF NEW.Quantidade < 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade não pode ser negativa";
    ELSEIF NEW.Quantidade = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade não pode ser nula";
    ELSEIF NEW.Preco < 0 AND NOT ISNULL(NEW.ProdutoID) THEN
		SET _error_msg = CONCAT("O valor do produto '", _descricao, "' não pode ser negativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF _ativo = 'N' AND NEW.Cancelado <> 'Y' THEN
		SET _error_msg = CONCAT("O funcionário '", _login, "' não está ativo");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF NEW.Visualizado = 'Y' AND ISNULL(NEW.DataVisualizacao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível atualizar um produto visualizado sem a data e a hora";
	ELSEIF NEW.Visualizado <> OLD.Visualizado AND ISNULL(NEW.DataVisualizacao) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data de visualização não pode mais ser nula";
	ELSEIF NOT ISNULL(NEW.ProdutoID) AND _divisivel = 'N' AND MOD(NEW.Quantidade, 1) > 0 THEN
		SET _error_msg = CONCAT("O produto '", _descricao, "' não é divisível");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	END IF;
    IF NEW.Cancelado = 'Y' AND NOT ISNULL(NEW.ProdutoID) AND NEW.Desperdicado = 'N' THEN
		UPDATE Estoque SET Cancelado = 'Y' WHERE TransacaoID = OLD.ID;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Cheques_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Cheques_BEFORE_INSERT` BEFORE INSERT ON `Cheques` FOR EACH ROW
BEGIN
IF @DISABLE_TRIGGERS IS NULL THEN
    
	IF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cheque não pode ser cadastrado já cancelado";
	END IF;
    
END IF;
END $$

DROP TRIGGER IF EXISTS `Creditos_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Creditos_BEFORE_INSERT` BEFORE INSERT ON `Creditos` FOR EACH ROW
BEGIN
IF @DISABLE_TRIGGERS IS NULL THEN
    
	IF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O crédito não pode ser cadastrado já cancelado";
	END IF;
    
END IF;
END $$

DROP TRIGGER IF EXISTS `Creditos_AFTER_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Creditos_AFTER_INSERT` AFTER INSERT ON `Creditos` FOR EACH ROW
BEGIN
    DECLARE _total DECIMAL(19,4);
IF @DISABLE_TRIGGERS IS NULL THEN

    IF NEW.Valor < 0 THEN
		SELECT SUM(Valor) INTO _total FROM Creditos
			WHERE ClienteID = NEW.ClienteID AND Cancelado = 'N';
		IF _total < 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cliente não possui créditos suficientes";
        END IF;
    END IF;
    
END IF;
END $$

DROP TRIGGER IF EXISTS `Creditos_AFTER_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Creditos_AFTER_UPDATE` AFTER UPDATE ON `Creditos` FOR EACH ROW
BEGIN
    DECLARE _total DECIMAL(19,4);
IF @DISABLE_TRIGGERS IS NULL THEN
    
    IF NEW.Valor < 0 OR (OLD.Cancelado = 'N' AND NEW.Cancelado = 'Y') THEN
		SELECT SUM(Valor) INTO _total FROM Creditos
			WHERE ClienteID = NEW.ClienteID AND Cancelado = 'N';
		IF _total < 0 AND NEW.Valor < 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cliente não possui créditos suficientes";
		ELSEIF _total < 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O cancelamento não pode negativar os créditos";
        END IF;
    END IF;
	IF OLD.Valor > 0 AND NEW.ClienteID <> OLD.ClienteID THEN
		SELECT SUM(Valor) INTO _total FROM Creditos
			WHERE ClienteID = OLD.ClienteID AND Cancelado = 'N';
		IF _total < 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A transferência não pode negativar os créditos do cliente";
		END IF;
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Pagamentos_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pagamentos_BEFORE_INSERT` BEFORE INSERT ON `Pagamentos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _nome, _estado VARCHAR(75);
	DECLARE _aberta, _cancelado VARCHAR(1);
	DECLARE _existe, _sessao_id, _forma_count INT DEFAULT 0;
    DECLARE _movimentacao_id INT DEFAULT NULL;
IF @DISABLE_TRIGGERS IS NULL THEN
    
	SELECT mv.Aberta, mv.SessaoID, c.Descricao INTO _aberta, _sessao_id, _nome FROM Movimentacoes mv
		LEFT JOIN Caixas c ON c.ID = mv.CaixaID
		WHERE mv.ID = NEW.MovimentacaoID;
	SET _forma_count = IF(ISNULL(NEW.CartaoID), 0, 1) + IF(ISNULL(NEW.ChequeID), 0, 1) + IF(ISNULL(NEW.ContaID), 0, 1) + IF(ISNULL(NEW.CreditoID), 0, 1);
	IF NOT ISNULL(NEW.MovimentacaoID) AND _aberta = 'N' THEN
		SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", NEW.MovimentacaoID, " já foi fechado");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível realizar um pagamento cancelado";
	ELSEIF _forma_count > 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Várias formas de pagamento em uma única transação";
	ELSEIF _forma_count = 0 AND (NEW.Parcelas > 0 OR NEW.ValorParcela < -0.005 OR NEW.ValorParcela > 0.005) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Parcelamento em uma forma de pagamento não parcelada";
	ELSEIF NEW.Total > -0.005 AND NEW.Total < 0.005 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Valor total não informado";
	ELSEIF NEW.Parcelas < 0 OR (NEW.Parcelas = 0 AND (NEW.ValorParcela < -0.005 OR NEW.ValorParcela > 0.005)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Parcelamento incorreto";
	ELSEIF _forma_count = 1 AND NEW.Parcelas = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Parcelamento não informado";
	ELSEIF NEW.Parcelas > 0 AND NEW.Parcelas * NEW.ValorParcela < NEW.Total - 0.005 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Total parcelado menor que o total do pagamento";
    ELSEIF NOT ISNULL(NEW.PedidoID) AND NOT ISNULL(NEW.PagtoContaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Vários destinos para o pagamento";
    ELSEIF ISNULL(NEW.PedidoID) AND ISNULL(NEW.PagtoContaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Nenhum destino para o pagamento";
    ELSEIF NOT ISNULL(NEW.ContaID) AND NEW.Ativo = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um pagamento inativo em conta";
    ELSEIF NOT ISNULL(NEW.CreditoID) AND NEW.Ativo = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir um pagamento inativo em crédito";
    ELSEIF NOT ISNULL(NEW.PedidoID) AND ISNULL(NEW.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A movimentação do caixa não foi informada para a realização do pagamento do pedido";
    ELSEIF NOT ISNULL(NEW.PedidoID) THEN
		SELECT MovimentacaoID, Estado, Cancelado INTO _movimentacao_id, _estado, _cancelado FROM Pedidos
			WHERE ID = NEW.PedidoID;
		IF _cancelado = 'Y' THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível realizar um pagamento em um pedido cancelado";
		ELSEIF _estado = 'Finalizado' THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível realizar um pagamento em um pedido finalizado";
		ELSEIF NOT ISNULL(_movimentacao_id) AND _movimentacao_id <> NEW.MovimentacaoID THEN
			SET _error_msg = CONCAT("O pedido já está associado à movimentação ", _movimentacao_id);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
		ELSEIF ISNULL(_movimentacao_id) THEN
			UPDATE Pedidos p
				LEFT JOIN Movimentacoes mv ON mv.ID = NEW.MovimentacaoID
                SET p.SessaoID = mv.SessaoID, p.MovimentacaoID = mv.ID 
				WHERE p.ID = NEW.PedidoID;
		END IF;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Pagamentos_AFTER_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pagamentos_AFTER_INSERT` AFTER INSERT ON `Pagamentos` FOR EACH ROW
BEGIN
	DECLARE _tipo VARCHAR(40);
	DECLARE _carteira VARCHAR(100);
	DECLARE _error_msg VARCHAR(255);
    DECLARE _dinheiro DECIMAL(19,4);
IF @DISABLE_TRIGGERS IS NULL THEN
    
    SELECT Tipo INTO _tipo FROM Formas_Pagto WHERE ID = NEW.FormaPagtoID;
	IF (_tipo = 'Dinheiro' OR _tipo = 'Transferencia') AND NEW.Total < 0 AND NEW.Ativo = 'Y' THEN
		SELECT SUM(pg.Total) INTO _dinheiro FROM Pagamentos pg
			LEFT JOIN Formas_Pagto fp ON fp.ID = pg.FormaPagtoID
			WHERE (ISNULL(NEW.MovimentacaoID) OR fp.Tipo IN ('Dinheiro', 'Transferencia')) AND (ISNULL(NEW.MovimentacaoID) OR pg.MovimentacaoID = NEW.MovimentacaoID) AND 
            pg.CarteiraID = NEW.CarteiraID AND pg.Ativo = 'Y' AND pg.Cancelado = 'N';
		IF _dinheiro < 0 THEN
			SELECT Descricao INTO _carteira FROM Carteiras WHERE ID = NEW.CarteiraID;
			SET _error_msg = CONCAT("Não há dinheiro suficiente na carteira '", _carteira, "'");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    END IF;
    
END IF;
END $$

DROP TRIGGER IF EXISTS `Pagamentos_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pagamentos_BEFORE_UPDATE` BEFORE UPDATE ON `Pagamentos` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _nome VARCHAR(75);
	DECLARE _aberta VARCHAR(1);
	DECLARE _existe, _sessao_id INT DEFAULT 0;
    DECLARE _movimentacao_id INT DEFAULT NULL;
IF @DISABLE_TRIGGERS IS NULL THEN
    
	SELECT mv.Aberta, mv.SessaoID, c.Descricao INTO _aberta, _sessao_id, _nome FROM Movimentacoes mv
		LEFT JOIN Caixas c ON c.ID = mv.CaixaID
		WHERE mv.ID = NEW.MovimentacaoID;
	IF NOT ISNULL(NEW.MovimentacaoID) AND _aberta = 'N' THEN
		SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", NEW.MovimentacaoID, " já foi fechado");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF OLD.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível alterar um pagamento que já foi cancelado";
	ELSEIF NEW.Total <> OLD.Total THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O valor total não pode ser alterado";
	ELSEIF NEW.Parcelas <> OLD.Parcelas OR NEW.ValorParcela <> OLD.ValorParcela THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O parcelamento não pode ser alterado";
	ELSEIF ISNULL(NEW.MovimentacaoID) <> ISNULL(OLD.MovimentacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O caixa do pagamento não pode ser alterado";
	ELSEIF NOT (NEW.CarteiraID <=> OLD.CarteiraID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A carteira do pagamento não pode ser alterada";
	ELSEIF NEW.FormaPagtoID <> OLD.FormaPagtoID OR NOT (NEW.CartaoID <=> OLD.CartaoID) OR NOT (NEW.ChequeID <=> OLD.ChequeID) OR
		   NOT (NEW.ContaID <=> OLD.ContaID) OR NOT (NEW.CreditoID <=> OLD.CreditoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A forma de pagamento não pode ser alterada";
	ELSEIF NEW.DataHora <> OLD.DataHora THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A data do pagamento não pode ser alterada";
	ELSEIF NOT (NEW.PedidoID <=> OLD.PedidoID) OR NOT (NEW.PagtoContaID <=> OLD.PagtoContaID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O destino do pagamento não pode ser alterado";
    ELSEIF NOT ISNULL(NEW.ContaID) AND NEW.Ativo = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível atualizar um pagamento em conta para inativo";
    ELSEIF NOT ISNULL(NEW.CreditoID) AND NEW.Ativo = 'N' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível atualizar um pagamento em crédito para inativo";
	ELSEIF NOT ISNULL(NEW.MovimentacaoID) AND NEW.MovimentacaoID <> OLD.MovimentacaoID THEN
		SELECT mv.Aberta, mv.SessaoID, c.Descricao INTO _aberta, _sessao_id, _nome FROM Movimentacoes mv
			LEFT JOIN Caixas c ON c.ID = mv.CaixaID
			WHERE mv.ID = OLD.MovimentacaoID;
		IF _aberta = 'N' THEN
			SET _error_msg = CONCAT("O caixa '", _nome, "' da movimentacão ", OLD.MovimentacaoID, " já foi fechado");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
		END IF;
        IF NOT ISNULL(NEW.PedidoID) THEN
			UPDATE Pedidos p
				LEFT JOIN Movimentacoes mv ON mv.ID = NEW.MovimentacaoID
                SET p.SessaoID = mv.SessaoID, p.MovimentacaoID = mv.ID 
				WHERE p.ID = NEW.PedidoID;
		END IF;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Pagamentos_AFTER_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pagamentos_AFTER_UPDATE` AFTER UPDATE ON `Pagamentos` FOR EACH ROW
BEGIN
	DECLARE _tipo VARCHAR(40);
    DECLARE _carteira VARCHAR(100);
    DECLARE _error_msg VARCHAR(255);
    DECLARE _dinheiro DECIMAL(19,4);
IF @DISABLE_TRIGGERS IS NULL THEN
    
    SELECT Tipo INTO _tipo FROM Formas_Pagto WHERE ID = NEW.FormaPagtoID;
	IF (_tipo = 'Dinheiro' OR _tipo = 'Transferencia') AND NEW.Total < 0 AND OLD.Ativo = 'N' AND NEW.Ativo = 'Y' THEN
		SELECT SUM(pg.Total) INTO _dinheiro FROM Pagamentos pg
			LEFT JOIN Formas_Pagto fp ON fp.ID = pg.FormaPagtoID
			WHERE (ISNULL(NEW.MovimentacaoID) OR fp.Tipo IN ('Dinheiro', 'Transferencia')) AND (ISNULL(NEW.MovimentacaoID) OR pg.MovimentacaoID = NEW.MovimentacaoID) AND 
            pg.CarteiraID = NEW.CarteiraID AND pg.Ativo = 'Y' AND pg.Cancelado = 'N';
		IF _dinheiro < 0 THEN
			SELECT Descricao INTO _carteira FROM Carteiras WHERE ID = NEW.CarteiraID;
			SET _error_msg = CONCAT("Não há dinheiro suficiente na carteira '", _carteira, "'");
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
        END IF;
    END IF;
	IF (OLD.Cancelado = 'N' OR OLD.ContaID <> NEW.ContaID) AND NEW.Cancelado = 'Y' AND NOT ISNULL(NEW.ContaID) THEN
		UPDATE Contas SET Cancelada = 'Y' WHERE ID = NEW.ContaID;
	ELSEIF (OLD.Cancelado = 'N' OR OLD.CreditoID <> NEW.CreditoID) AND NEW.Cancelado = 'Y' AND NOT ISNULL(NEW.CreditoID) THEN
		UPDATE Creditos SET Cancelado = 'Y' WHERE ID = NEW.CreditoID;
	ELSEIF (OLD.Cancelado = 'N' OR OLD.ChequeID <> NEW.ChequeID) AND NEW.Cancelado = 'Y' AND NOT ISNULL(NEW.ChequeID) THEN
		UPDATE Cheques SET Cancelado = 'Y' WHERE ID = NEW.ChequeID;
	END IF;
    
END IF;
END $$

DROP TRIGGER IF EXISTS `Estoque_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Estoque_BEFORE_INSERT` BEFORE INSERT ON `Estoque` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _descricao VARCHAR(75);
	DECLARE _tipo VARCHAR(20);
	DECLARE _divisivel VARCHAR(1);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Descricao, Tipo, Divisivel
	INTO _descricao, _tipo, _divisivel
	FROM Produtos
	WHERE ID = NEW.ProdutoID;
    IF NEW.Cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível inserir no estoque uma entrada cancelada";
    ELSEIF NEW.Quantidade = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A quantidade não pode ser nula";
    ELSEIF NEW.Quantidade > 0 AND NOT ISNULL(NEW.TransacaoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A venda não pode adicionar o produto ao estoque";
	ELSEIF _tipo = 'Composicao' THEN
		SET _error_msg = CONCAT("O produto '", _descricao, "' é uma composição e não pode ser ", IF(NEW.Quantidade < 0, 'removido do', 'inserido no'), " estoque");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF _tipo = 'Pacote' THEN
		SET _error_msg = CONCAT("O produto '", _descricao, "' é um pacote e não pode ser ", IF(NEW.Quantidade < 0, 'removido do', 'inserido no'), " estoque");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	ELSEIF _divisivel = 'N' AND MOD(NEW.Quantidade, 1) > 0 THEN
		SET _error_msg = CONCAT("O produto '", _descricao, "' não é divisível");
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = _error_msg;
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Estoque_AFTER_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Estoque_AFTER_INSERT` AFTER INSERT ON `Estoque` FOR EACH ROW
BEGIN
IF @DISABLE_TRIGGERS IS NULL THEN
    IF NOT ISNULL(NEW.TransacaoID) then
		UPDATE Produtos_Pedidos SET PrecoCompra = PrecoCompra + (-NEW.Quantidade * NEW.PrecoCompra) / Quantidade
			WHERE ID = NEW.TransacaoID;
    END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Pacotes_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pacotes_BEFORE_INSERT` BEFORE INSERT ON `Pacotes` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _count, _prod_count, _prop_count INT DEFAULT 0;
    DECLARE _grupo_id INT DEFAULT NULL;
	DECLARE _multiplo VARCHAR(1);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Multiplo INTO _multiplo FROM Grupos WHERE ID = NEW.GrupoID;
    SELECT COALESCE(SUM(IF(ISNULL(ProdutoID), 0, 1)), 0), COALESCE(SUM(IF(ISNULL(PropriedadeID), 0, 1)), 0) INTO _prod_count, _prop_count
		FROM Pacotes WHERE GrupoID = NEW.GrupoID;
    
    IF ISNULL(NEW.ProdutoID) AND ISNULL(NEW.PropriedadeID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Um produto ou propriedade deve ser informado";
    ELSEIF NOT ISNULL(NEW.ProdutoID) AND NOT ISNULL(NEW.PropriedadeID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Produto e propriedade não deve ser informado ao mesmo tempo";
    END IF;
    IF NOT ISNULL(NEW.ProdutoID) THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND ProdutoID = NEW.ProdutoID AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O produto informado já está cadastrado";
        END IF;
    ELSEIF NOT ISNULL(NEW.PropriedadeID) THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND PropriedadeID = NEW.PropriedadeID AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A propriedade informada já está cadastrada";
        END IF;
	END IF;
    IF NEW.Selecionado = 'Y' AND _multiplo = 'N' THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND Selecionado = 'Y' AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe outro pacote selecionado e esse grupo não permite múltiplos itens";
        END IF;
    END IF;
    IF (_prod_count > 0 AND NOT ISNULL(NEW.PropriedadeID)) OR (_prop_count > 0 AND NOT ISNULL(NEW.ProdutoID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Em um grupo não pode existir produto e propriedade juntos";
    ELSE
		SELECT GrupoID INTO _grupo_id FROM Pacotes WHERE ID = NEW.AssociacaoID;
    	SELECT COUNT(pc.ID) INTO _count FROM Pacotes pc 
			LEFT JOIN Pacotes pca ON pca.ID = pc.AssociacaoID
			WHERE pc.GrupoID = NEW.GrupoID AND NOT (pca.GrupoID <=> _grupo_id);
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Os pacotes desse grupo estão associados a um grupo diferente do grupo da associação";
        END IF;
    END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Pacotes_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Pacotes_BEFORE_UPDATE` BEFORE UPDATE ON `Pacotes` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _count, _prod_count, _prop_count INT DEFAULT 0;
    DECLARE _grupo_id INT DEFAULT NULL;
	DECLARE _multiplo VARCHAR(1);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Multiplo INTO _multiplo FROM Grupos WHERE ID = NEW.GrupoID;
    SELECT COALESCE(SUM(IF(ISNULL(ProdutoID), 0, 1)), 0), COALESCE(SUM(IF(ISNULL(PropriedadeID), 0, 1)), 0) INTO _prod_count, _prop_count
		FROM Pacotes WHERE GrupoID = NEW.GrupoID AND ID <> OLD.ID;
    
    IF ISNULL(NEW.ProdutoID) AND ISNULL(NEW.PropriedadeID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Um produto ou propriedade deve ser informado";
    ELSEIF NOT ISNULL(NEW.ProdutoID) AND NOT ISNULL(NEW.PropriedadeID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Produto e propriedade não deve ser informado ao mesmo tempo";
    END IF;
    IF NOT ISNULL(NEW.ProdutoID) THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND ProdutoID = NEW.ProdutoID AND ID <> OLD.ID AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O produto informado já está cadastrado";
        END IF;
    ELSEIF NOT ISNULL(NEW.PropriedadeID) THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND PropriedadeID = NEW.PropriedadeID AND ID <> OLD.ID AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A propriedade informada já está cadastrada";
        END IF;
	END IF;
    IF NEW.Selecionado = 'Y' AND _multiplo = 'N' THEN
		SELECT COUNT(ID) INTO _count FROM Pacotes WHERE GrupoID = NEW.GrupoID AND ID <> OLD.ID AND Selecionado = 'Y' AND AssociacaoID <=> NEW.AssociacaoID;
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe outro pacote selecionado e esse grupo não permite múltiplos itens";
        END IF;
    END IF;
    IF (_prod_count > 0 AND NOT ISNULL(NEW.PropriedadeID)) OR (_prop_count > 0 AND NOT ISNULL(NEW.ProdutoID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Em um grupo não pode existir produto e propriedade juntos";
    ELSE
		SELECT GrupoID INTO _grupo_id FROM Pacotes WHERE ID = NEW.AssociacaoID;
    	SELECT COUNT(pc.ID) INTO _count FROM Pacotes pc 
			LEFT JOIN Pacotes pca ON pca.ID = pc.AssociacaoID
			WHERE pc.GrupoID = NEW.GrupoID AND pc.ID <> OLD.ID AND NOT (pca.GrupoID <=> _grupo_id);
        IF _count > 0 THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Os pacotes desse grupo estão associados a um grupo diferente do grupo da associação";
        END IF;
    END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Promocoes_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Promocoes_BEFORE_INSERT` BEFORE INSERT ON `Promocoes` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Promocoes WHERE ProdutoID = NEW.ProdutoID AND (
		(DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL NEW.Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)) OR
		(DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL     Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)));
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma promoção nesse intervalo";
	END IF;

END IF;
END
$$


DROP TRIGGER IF EXISTS `Promocoes_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Promocoes_BEFORE_UPDATE` BEFORE UPDATE ON `Promocoes` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Promocoes WHERE ProdutoID = NEW.ProdutoID AND ID <> OLD.ID AND (
		(DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL NEW.Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)) OR
		(DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL     Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)));
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma promoção nesse intervalo";
	END IF;

END IF;
END
$$


DROP TRIGGER IF EXISTS `Horarios_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Horarios_BEFORE_INSERT` BEFORE INSERT ON `Horarios` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Horarios WHERE
		(DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL NEW.Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)) OR
		(DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL     Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE));
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe um horário nesse intervalo";
	END IF;

END IF;
END
$$


DROP TRIGGER IF EXISTS `Horarios_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Horarios_BEFORE_UPDATE` BEFORE UPDATE ON `Horarios` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Horarios WHERE ID <> OLD.ID AND (
		(DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL NEW.Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)) OR
		(DATE_ADD(CURDATE(), INTERVAL NEW.Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) BETWEEN 
		 DATE_ADD(CURDATE(), INTERVAL     Inicio - DAYOFWEEK(CURDATE()) * 1440 MINUTE) AND DATE_ADD(CURDATE(), INTERVAL     Fim - DAYOFWEEK(CURDATE()) * 1440 MINUTE)));
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe um horário nesse intervalo";
	END IF;

END IF;
END
$$


DROP TRIGGER IF EXISTS `Transferencias_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Transferencias_BEFORE_INSERT` BEFORE INSERT ON `Transferencias` FOR EACH ROW
BEGIN
	DECLARE _error_msg VARCHAR(255);
	DECLARE _estado, _estado_dest VARCHAR(75);
	DECLARE _cancelado, _cancelado_dest VARCHAR(1);
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT Cancelado, Estado INTO _cancelado, _estado FROM Pedidos WHERE ID = NEW.PedidoID;
	SELECT Cancelado, Estado INTO _cancelado_dest, _estado_dest FROM Pedidos WHERE ID = NEW.DestinoPedidoID;
    
    IF NEW.Modulo = 'Mesa' AND (ISNULL(NEW.MesaID) OR ISNULL(NEW.DestinoMesaID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa de origem e destino deve ser informada";
    ELSEIF NEW.Modulo = 'Comanda' AND (ISNULL(NEW.ComandaID) OR ISNULL(NEW.DestinoComandaID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A comanda de origem e destino deve ser informada";
    ELSEIF NEW.Modulo = 'Mesa' AND (NOT ISNULL(NEW.ComandaID) OR NOT ISNULL(NEW.DestinoComandaID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A comanda não deve ser informada em transferência de mesas";
    ELSEIF NEW.Modulo = 'Comanda' AND (NOT ISNULL(NEW.MesaID) OR NOT ISNULL(NEW.DestinoMesaID)) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa não deve ser informada em transferência de comandas";
    ELSEIF NEW.Tipo = 'Produto' AND ISNULL(NEW.ProdutoPedidoID) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A produto a ser transferido deve ser informado";
    ELSEIF _cancelado = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível transferir de um pedido cancelado";
    ELSEIF _estado = 'Finalizado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível transferir de um pedido finalizado";
    ELSEIF _cancelado_dest = 'Y' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível transferir para um pedido cancelado";
    ELSEIF _estado_dest = 'Finalizado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Não é possível transferir para um pedido finalizado";
	END IF;
END IF;
END $$

DROP TRIGGER IF EXISTS `Juncoes_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Juncoes_BEFORE_INSERT` BEFORE INSERT ON `Juncoes` FOR EACH ROW
BEGIN
	DECLARE _tipo VARCHAR(75);
	DECLARE _existe, _aberto, _mesa_id INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT 1 INTO _existe FROM Juncoes WHERE MesaID = NEW.MesaID AND Estado = 'Associado';
	SELECT 1, Tipo, MesaID INTO _aberto, _tipo, _mesa_id FROM Pedidos WHERE ID = NEW.PedidoID AND Estado <> 'Finalizado' AND Cancelado = 'N';
    
	IF _existe = 1 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa informada já está junta com outra mesa";
    ELSEIF _aberto = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa de destino precisa estar aberta";
    ELSEIF _mesa_id = NEW.MesaID THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa não pode juntar com ela mesma";
    ELSEIF _tipo <> 'Mesa' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido de destino deve ser de uma mesa";
    ELSEIF NEW.Estado <> 'Associado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A junção deve ser cadastrada como associada";
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Juncoes_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Juncoes_BEFORE_UPDATE` BEFORE UPDATE ON `Juncoes` FOR EACH ROW
BEGIN
	DECLARE _tipo VARCHAR(75);
	DECLARE _existe, _aberto, _mesa_id INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN
	
	SELECT 1 INTO _existe FROM Juncoes WHERE MesaID = NEW.MesaID AND Estado = 'Associado' AND ID <> OLD.ID;
	SELECT 1, Tipo, MesaID INTO _aberto, _tipo, _mesa_id FROM Pedidos WHERE ID = NEW.PedidoID AND Estado <> 'Finalizado' AND Cancelado = 'N';
    
	IF _existe = 1 AND NEW.Estado = 'Associado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa informada já está junta com outra mesa";
    ELSEIF _aberto = 0 AND NEW.Estado = 'Associado' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa de destino precisa estar aberta";
    ELSEIF _aberto = 1 AND _mesa_id = NEW.MesaID THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "A mesa não pode juntar com ela mesma";
    ELSEIF _aberto = 1 AND _tipo <> 'Mesa' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O pedido de destino deve ser de uma mesa";
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Notas_BEFORE_INSERT` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Notas_BEFORE_INSERT` BEFORE INSERT ON `Notas` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Notas WHERE
		((NumeroInicial BETWEEN NEW.NumeroInicial AND NEW.NumeroFinal) OR
		(NEW.NumeroInicial BETWEEN NumeroInicial AND NumeroFinal)) AND 
        Sequencia = NEW.Sequencia AND Serie = NEW.Serie AND Ambiente = NEW.Ambiente;
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma nota com esse número ou nesse intervalo";
	ELSEIF NEW.NumeroFinal > 999999999 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da nota não pode ser maior que 999.999.999";
	ELSEIF NEW.NumeroInicial <= 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da nota não pode ser nulo ou negativo";
	ELSEIF NEW.NumeroInicial > NEW.NumeroFinal THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número inicial da nota não pode ser maior que o número final";
	END IF;

END IF;
END $$

DROP TRIGGER IF EXISTS `Notas_BEFORE_UPDATE` $$
CREATE DEFINER = CURRENT_USER TRIGGER `Notas_BEFORE_UPDATE` BEFORE UPDATE ON `Notas` FOR EACH ROW
BEGIN
	DECLARE _count INT DEFAULT 0;
IF @DISABLE_TRIGGERS IS NULL THEN

	SELECT COUNT(ID) INTO _count FROM Notas WHERE ID <> OLD.ID AND
		((NumeroInicial BETWEEN NEW.NumeroInicial AND NEW.NumeroFinal) OR
		(NEW.NumeroInicial BETWEEN NumeroInicial AND NumeroFinal)) AND 
        Sequencia = NEW.Sequencia AND Serie = NEW.Serie AND Ambiente = NEW.Ambiente;
	IF _count > 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "Já existe uma nota com esse número ou nesse intervalo";
	ELSEIF NEW.NumeroFinal > 999999999 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da nota não pode ser maior que 999.999.999";
	ELSEIF NEW.NumeroInicial <= 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número da nota não pode ser nulo ou negativo";
	ELSEIF NEW.NumeroInicial > NEW.NumeroFinal THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "O número inicial da nota não pode ser maior que o número final";
	END IF;

END IF;
END $$

DELIMITER ;

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
